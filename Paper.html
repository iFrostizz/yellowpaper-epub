<p><span>2</span></p>
<h1 id="sec:introduction">Introduction</h1>
<p>With ubiquitous internet connections in most places of the world, global information transmission has become incredibly cheap. Technology-rooted movements like Bitcoin have demonstrated through the power of the default, consensus mechanisms, and voluntary respect of the social contract, that it is possible to use the internet to make a decentralised value-transfer system that can be shared across the world and virtually free to use. This system can be said to be a very specialised version of a cryptographically secure, transaction-based state machine. Follow-up systems such as Namecoin adapted this original “currency application” of the technology into other applications albeit rather simplistic ones.</p>
<p>Ethereum is a project which attempts to build the generalised technology; technology on which all transaction-based state machine concepts may be built. Moreover it aims to provide to the end-developer a tightly integrated end-to-end system for building software on a hitherto unexplored compute paradigm in the mainstream: a trustful object messaging compute framework.</p>
<h2 id="ch:driving">Driving Factors</h2>
<p>There are many goals of this project; one key goal is to facilitate transactions between consenting individuals who would otherwise have no means to trust one another. This may be due to geographical separation, interfacing difficulty, or perhaps the incompatibility, incompetence, unwillingness, expense, uncertainty, inconvenience, or corruption of existing legal systems. By specifying a state-change system through a rich and unambiguous language, and furthermore architecting a system such that we can reasonably expect that an agreement will be thus enforced autonomously, we can provide a means to this end.</p>
<p>Dealings in this proposed system would have several attributes not often found in the real world. The incorruptibility of judgement, often difficult to find, comes naturally from a disinterested algorithmic interpreter. Transparency, or being able to see exactly how a state or judgement came about through the transaction log and rules or instructional codes, never happens perfectly in human-based systems since natural language is necessarily vague, information is often lacking, and plain old prejudices are difficult to shake.</p>
<p>Overall, we wish to provide a system such that users can be guaranteed that no matter with which other individuals, systems or organisations they interact, they can do so with absolute confidence in the possible outcomes and how those outcomes might come about.</p>
<h2 id="ch:previous">Previous Work</h2>
<p><span class="citation" data-cites="buterin2013ethereum"></span> first proposed the kernel of this work in late November, 2013. Though now evolved in many ways, the key functionality of a block-chain with a Turing-complete language and an effectively unlimited inter-transaction storage capability remains unchanged.</p>
<p><span class="citation" data-cites="dwork92pricingvia"></span> provided the first work into the usage of a cryptographic proof of computational expenditure (“proof-of-work”) as a means of transmitting a value signal over the Internet. The value-signal was utilised here as a spam deterrence mechanism rather than any kind of currency, but critically demonstrated the potential for a basic data channel to carry a <em>strong economic signal</em>, allowing a receiver to make a physical assertion without having to rely upon <em>trust</em>. <span class="citation" data-cites="back2002hashcash"></span> later produced a system in a similar vein.</p>
<p>The first example of utilising the proof-of-work as a strong economic signal to secure a currency was by <span class="citation" data-cites="vishnumurthy03karma:a"></span>. In this instance, the token was used to keep peer-to-peer file trading in check, providing “consumers” with the ability to make micro-payments to “suppliers” for their services. The security model afforded by the proof-of-work was augmented with digital signatures and a ledger in order to ensure that the historical record couldn’t be corrupted and that malicious actors could not spoof payment or unjustly complain about service delivery. Five years later, <span class="citation" data-cites="nakamoto2008bitcoin"></span> introduced another such proof-of-work-secured value token, somewhat wider in scope. The fruits of this project, Bitcoin, became the first widely adopted global decentralised transaction ledger.</p>
<p>Other projects built on Bitcoin’s success; the alt-coins introduced numerous other currencies through alteration to the protocol. Some of the best known are Litecoin and Primecoin, discussed by <span class="citation" data-cites="sprankel2013technical"></span>. Other projects sought to take the core value content mechanism of the protocol and repurpose it; <span class="citation" data-cites="aron2012bitcoin"></span> discusses, for example, the Namecoin project which aims to provide a decentralised name-resolution system.</p>
<p>Other projects still aim to build upon the Bitcoin network itself, leveraging the large amount of value placed in the system and the vast amount of computation that goes into the consensus mechanism. The Mastercoin project, first proposed by <span class="citation" data-cites="mastercoin2013willett"></span>, aims to build a richer protocol involving many additional high-level features on top of the Bitcoin protocol through utilisation of a number of auxiliary parts to the core protocol. The Coloured Coins project, proposed by <span class="citation" data-cites="colouredcoins2012rosenfeld"></span>, takes a similar but more simplified strategy, embellishing the rules of a transaction in order to break the fungibility of Bitcoin’s base currency and allow the creation and tracking of tokens through a special “chroma-wallet”-protocol-aware piece of software.</p>
<p>Additional work has been done in the area with discarding the decentralisation foundation; Ripple, discussed by <span class="citation" data-cites="boutellier2014pirates"></span>, has sought to create a “federated” system for currency exchange, effectively creating a new financial clearing system. It has demonstrated that high efficiency gains can be made if the decentralisation premise is discarded.</p>
<p>Early work on smart contracts has been done by <span class="citation" data-cites="szabo1997formalizing"></span> and <span class="citation" data-cites="miller1997future"></span>. Around the 1990s it became clear that algorithmic enforcement of agreements could become a significant force in human cooperation. Though no specific system was proposed to implement such a system, it was proposed that the future of law would be heavily affected by such systems. In this light, Ethereum may be seen as a general implementation of such a <em>crypto-law</em> system.</p>
<p>For a list of terms used in this paper, refer to Appendix <a href="#ch:Terminology" data-reference-type="ref" data-reference="ch:Terminology">17</a>.</p>
<h1 id="ch:overview">The Blockchain Paradigm</h1>
<p>Ethereum, taken as a whole, can be viewed as a transaction-based state machine: we begin with a genesis state and incrementally execute transactions to morph it into some current state. It is this current state which we accept as the canonical “version” of the world of Ethereum. The state can include such information as account balances, reputations, trust arrangements, data pertaining to information of the physical world; in short, anything that can currently be represented by a computer is admissible. Transactions thus represent a valid arc between two states; the ‘valid’ part is important—there exist far more invalid state changes than valid state changes. Invalid state changes might, e.g., be things such as reducing an account balance without an equal and opposite increase elsewhere. A valid state transition is one which comes about through a transaction. Formally: <br /><span class="math display">$$\Hy@raisedlink{\hypertarget{Upsilon_state_transition}{}}\Hy@raisedlink{\hypertarget{Upsilon}{}}\boldsymbol{\sigma}_{t+1} \equiv \Upsilon(\boldsymbol{\sigma}_{t}, T)$$</span><br /></p>
<p>where <span class="math inline"><em>Υ</em></span> is the Ethereum state transition function. In Ethereum, <span class="math inline"><em>Υ</em></span>, together with <span class="math inline"><strong>σ</strong></span> are considerably more powerful than any existing comparable system; <span class="math inline"><em>Υ</em></span> allows components to carry out arbitrary computation, while <span class="math inline"><strong>σ</strong></span> allows components to store arbitrary state between transactions.</p>
<p>Transactions are collated into blocks; blocks are chained together using a cryptographic hash as a means of reference. Blocks function as a journal, recording a series of transactions together with the previous block and an identifier for the final state (though do not store the final state itself—that would be far too big). They also punctuate the transaction series with incentives for nodes to <em>mine</em>. This incentivisation takes place as a state-transition function, adding value to a nominated account.</p>
<p>Mining is the process of dedicating effort (working) to bolster one series of transactions (a block) over any other potential competitor block. It is achieved thanks to a cryptographically secure proof. This scheme is known as a proof-of-work and is discussed in detail in section <a href="#ch:pow" data-reference-type="ref" data-reference="ch:pow">11.5</a>.</p>
<p>Formally, we expand to: <br /><span class="math display">$$\begin{aligned}
\boldsymbol{\sigma}_{t+1} &amp; \equiv &amp; \hyperlink{Pi}{\Pi}(\boldsymbol{\sigma}_{t}, B) \\
B &amp; \equiv &amp; (..., (T_0, T_1, ...), ...) \\
\Pi(\boldsymbol{\sigma}, B) &amp; \equiv &amp; \hyperlink{Omega}{\Omega}(B, \hyperlink{Upsilon}{\Upsilon}(\Upsilon(\boldsymbol{\sigma}, T_0), T_1) ...)\end{aligned}$$</span><br /></p>
<p>Where <a href="#Omega"><span class="math inline"><em>Ω</em></span></a> is the block-finalisation state transition function (a function that rewards a nominated party); <a href="#block"><span class="math inline"><em>B</em></span></a> is this block, which includes a series of transactions amongst some other components; and <span class="math inline">$\hyperlink{Pi}{\Pi}$</span> is the block-level state-transition function.</p>
<p>This is the basis of the blockchain paradigm, a model that forms the backbone of not only Ethereum, but all decentralised consensus-based transaction systems to date.</p>
<h2 id="value">Value</h2>
<p>In order to incentivise computation within the network, there needs to be an agreed method for transmitting value. To address this issue, Ethereum has an intrinsic currency, Ether, known also as <span>ETH</span> and sometimes referred to by the Old English . The smallest subdenomination of Ether, and thus the one in which all integer values of the currency are counted, is the Wei. One Ether is defined as being <span class="math inline">10<sup>18</sup></span> Wei. There exist other subdenominations of Ether:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Multiplier</th>
<th style="text-align: left;">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">10<sup>0</sup></span></td>
<td style="text-align: left;">Wei</td>
</tr>
<tr class="even">
<td style="text-align: right;"><span class="math inline">10<sup>12</sup></span></td>
<td style="text-align: left;">Szabo</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">10<sup>15</sup></span></td>
<td style="text-align: left;">Finney</td>
</tr>
<tr class="even">
<td style="text-align: right;"><span class="math inline">10<sup>18</sup></span></td>
<td style="text-align: left;">Ether</td>
</tr>
</tbody>
</table>
<p>Throughout the present work, any reference to value, in the context of Ether, currency, a balance or a payment, should be assumed to be counted in Wei.</p>
<h2 id="which-history">Which History?</h2>
<p>Since the system is decentralised and all parties have an opportunity to create a new block on some older pre-existing block, the resultant structure is necessarily a tree of blocks. In order to form a consensus as to which path, from root (<a href="#Genesis_Block">the genesis block</a>) to leaf (the block containing the most recent transactions) through this tree structure, known as the blockchain, there must be an agreed-upon scheme. If there is ever a disagreement between nodes as to which root-to-leaf path down the block tree is the ‘best’ blockchain, then a <em>fork</em> occurs.</p>
<p>This would mean that past a given point in time (block), multiple states of the system may coexist: some nodes believing one block to contain the canonical transactions, other nodes believing some other block to be canonical, potentially containing radically different or incompatible transactions. This is to be avoided at all costs as the uncertainty that would ensue would likely kill all confidence in the entire system.</p>
<p>The scheme we use in order to generate consensus is a simplified version of the GHOST protocol introduced by <span class="citation" data-cites="cryptoeprint:2013:881"></span>. This process is described in detail in section <a href="#ch:ghost" data-reference-type="ref" data-reference="ch:ghost">10</a>.</p>
<p>Sometimes, a path follows a new protocol from a particular height (block number). This document describes one version of the protocol, namely the <em>Berlin</em> version defined by <span class="citation" data-cites="BeikoBerlin"></span>. In order to follow back the history of a path, one must reference multiple versions of this document. Here are the block numbers of protocol updates on the Ethereum main network:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: right;">First Block Number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>H</em><em>o</em><em>m</em><em>e</em><em>s</em><em>t</em><em>e</em><em>a</em><em>d</em></sub></span></td>
<td style="text-align: right;">1150000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>T</em><em>a</em><em>n</em><em>g</em><em>e</em><em>r</em><em>i</em><em>n</em><em>e</em><em>W</em><em>h</em><em>i</em><em>s</em><em>t</em><em>l</em><em>e</em></sub></span></td>
<td style="text-align: right;">2463000</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>S</em><em>p</em><em>u</em><em>r</em><em>i</em><em>o</em><em>u</em><em>s</em><em>D</em><em>r</em><em>a</em><em>g</em><em>o</em><em>n</em></sub></span></td>
<td style="text-align: right;">2675000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>B</em><em>y</em><em>z</em><em>a</em><em>n</em><em>t</em><em>i</em><em>u</em><em>m</em></sub></span></td>
<td style="text-align: right;">4370000</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>C</em><em>o</em><em>n</em><em>s</em><em>t</em><em>a</em><em>n</em><em>t</em><em>i</em><em>n</em><em>o</em><em>p</em><em>l</em><em>e</em></sub></span></td>
<td style="text-align: right;">7280000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>P</em><em>e</em><em>t</em><em>e</em><em>r</em><em>s</em><em>b</em><em>u</em><em>r</em><em>g</em></sub></span></td>
<td style="text-align: right;">7280000</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>I</em><em>s</em><em>t</em><em>a</em><em>n</em><em>b</em><em>u</em><em>l</em></sub></span></td>
<td style="text-align: right;">9069000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>M</em><em>u</em><em>i</em><em>r</em><em>G</em><em>l</em><em>a</em><em>c</em><em>i</em><em>e</em><em>r</em></sub></span></td>
<td style="text-align: right;">9200000</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>B</em><em>e</em><em>r</em><em>l</em><em>i</em><em>n</em></sub></span></td>
<td style="text-align: right;">12244000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>L</em><em>o</em><em>n</em><em>d</em><em>o</em><em>n</em></sub></span></td>
<td style="text-align: right;">12965000</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>A</em><em>r</em><em>r</em><em>o</em><em>w</em><em>G</em><em>l</em><em>a</em><em>c</em><em>i</em><em>e</em><em>r</em></sub></span></td>
<td style="text-align: right;">13773000</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>F</em><sub><em>G</em><em>r</em><em>a</em><em>y</em><em>G</em><em>l</em><em>a</em><em>c</em><em>i</em><em>e</em><em>r</em></sub></span></td>
<td style="text-align: right;">15050000</td>
</tr>
</tbody>
</table>
<p>Occasionally actors do not agree on a protocol change, and a permanent fork occurs. In order to distinguish between diverged blockchains, EIP-155 by <span class="citation" data-cites="EIP-155"></span> introduced the concept of chain ID, which we denote by <span class="math inline"><em>β</em></span>. For the Ethereum main network <br /><span class="math display">$$\Hy@raisedlink{\hypertarget{chain_id}{}}
  \beta = 1$$</span><br /></p>
<h1 id="ch:conventions">Conventions</h1>
<p>We use a number of typographical conventions for the formal notation, some of which are quite particular to the present work:</p>
<p>The two sets of highly structured, ‘top-level’, state values, are denoted with bold lowercase Greek letters. They fall into those of world-state, which are denoted <span class="math inline"><strong>σ</strong></span> (or a variant thereupon) and those of machine-state, <span class="math inline"><strong>μ</strong></span>.</p>
<p>Functions operating on highly structured values are denoted with an upper-case Greek letter, e.g.<a href="#Upsilon_state_transition"><span class="math inline"><em>Υ</em></span></a>, the Ethereum state transition function.</p>
<p>For most functions, an uppercase letter is used, e.g. <span class="math inline"><em>C</em></span>, the general cost function. These may be subscripted to denote specialised variants, e.g.<a href="#C__SSTORE"><span class="math inline"><em>C</em><sub>SSTORE</sub></span></a>, the cost function for the <a href="#SSTORE">SSTORE</a> operation. For specialised and possibly externally defined functions, we may format as typewriter text, e.g. the Keccak-256 hash function (as per version 3 of the winning entry to the SHA-3 contest by <span class="citation" data-cites="Keccak"></span>, rather than the final SHA-3 specification), is denoted <span class="math inline"><code>KEC</code></span> (and generally referred to as plain Keccak). Also, <span class="math inline"><code>KEC512</code></span> refers to the Keccak-512 hash function.</p>
<p>Tuples are typically denoted with an upper-case letter, e.g.<span class="math inline"><em>T</em></span>, is used to denote an Ethereum transaction. This symbol may, if accordingly defined, be subscripted to refer to an individual component, e.g.<a href="#transaction_nonce"><span class="math inline"><em>T</em><sub><em>n</em></sub></span></a>, denotes the nonce of said transaction. The form of the subscript is used to denote its type; e.g. uppercase subscripts refer to tuples with subscriptable components.</p>
<p>Scalars and fixed-size byte sequences (or, synonymously, arrays) are denoted with a normal lower-case letter, e.g.<span class="math inline"><em>n</em></span> is used in the document to denote a <a href="#transaction_nonce">transaction nonce</a>. Those with a particularly special meaning may be Greek, e.g.<span class="math inline"><em>δ</em></span>, the number of items required on the stack for a given operation.</p>
<p>Arbitrary-length sequences are typically denoted as a bold lower-case letter, e.g.<span class="math inline"><strong>o</strong></span> is used to denote the byte sequence given as the output data of a message call. For particularly important values, a bold uppercase letter may be used.</p>
<p>Throughout, we assume scalars are non-negative integers and thus belong to the set <span class="math inline">ℕ</span>. The set of all byte sequences is <span class="math inline">𝔹</span>, formally defined in Appendix <a href="#app:rlp" data-reference-type="ref" data-reference="app:rlp">18</a>. If such a set of sequences is restricted to those of a particular length, it is denoted with a subscript, thus the set of all byte sequences of length <span class="math inline">32</span> is named <span class="math inline">𝔹<sub>32</sub></span> and the set of all non-negative integers smaller than <span class="math inline">2<sup>256</sup></span> is named <span class="math inline">ℕ<sub>256</sub></span>. This is formally defined in section <a href="#block"><a href="#subsec:The_Block" data-reference-type="ref" data-reference="subsec:The_Block">[subsec:The_Block]</a></a>.</p>
<p>Square brackets are used to index into and reference individual components or subsequences of sequences, e.g.<span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[0]</span> denotes the first item on the machine’s stack. For subsequences, ellipses are used to specify the intended range, to include elements at both limits, e.g.<span class="math inline"><strong>μ</strong><sub><strong>m</strong></sub>[0..31]</span> denotes the first 32 items of the machine’s memory.</p>
<p>In the case of the global state <span class="math inline"><strong>σ</strong></span>, which is a sequence of accounts, themselves tuples, the square brackets are used to reference an individual account.</p>
<p>When considering variants of existing values, we follow the rule that within a given scope for definition, if we assume that the unmodified ‘input’ value be denoted by the placeholder <span class="math inline">□</span> then the modified and utilisable value is denoted as <span class="math inline">□′</span>, and intermediate values would be <span class="math inline">□<sup>*</sup></span>, <span class="math inline">□<sup> * *</sup></span> &amp;c. On very particular occasions, in order to maximise readability and only if unambiguous in meaning, we may use alpha-numeric subscripts to denote intermediate values, especially those of particular note.</p>
<p>When considering the use of existing functions, given a function <span class="math inline"><em>f</em></span>, the function <a href="#general_element_wise_sequence_transformation_f_pow_asterisk"><span class="math inline"><em>f</em><sup>*</sup></span></a> denotes a similar, element-wise version of the function mapping instead between sequences. It is formally defined in section <a href="#block"><a href="#subsec:The_Block" data-reference-type="ref" data-reference="subsec:The_Block">[subsec:The_Block]</a></a>.</p>
<p>We define a number of useful functions throughout. One of the more common is <span class="math inline">ℓ</span>, which evaluates to the last item in the given sequence:</p>
<p><br /><span class="math display">ℓ(<strong>x</strong>) ≡ <strong>x</strong>[∥<strong>x</strong>∥ − 1]</span><br /></p>
<h1 id="ch:bst">Blocks, State and Transactions</h1>
<p>Having introduced the basic concepts behind Ethereum, we will discuss the meaning of a transaction, a block and the state in more detail.</p>
<h2 id="ch:state">World State</h2>
<p>The world state (<em>state</em>), is a mapping between addresses (160-bit identifiers) and account states (a data structure serialised as RLP, see Appendix <a href="#app:rlp" data-reference-type="ref" data-reference="app:rlp">18</a>). Though not stored on the blockchain, it is assumed that the implementation will maintain this mapping in a modified Merkle Patricia tree (<em>trie</em>, see Appendix <a href="#app:trie" data-reference-type="ref" data-reference="app:trie">20</a>). The trie requires a simple database backend that maintains a mapping of byte arrays to byte arrays; we name this underlying database the state database. This has a number of benefits; firstly the root node of this structure is cryptographically dependent on all internal data and as such its hash can be used as a secure identity for the entire system state. Secondly, being an immutable data structure, it allows any previous state (whose root hash is known) to be recalled by simply altering the root hash accordingly. Since we store all such root hashes in the blockchain, we are able to trivially revert to old states.</p>
<p>The account state, <span class="math inline"><strong>σ</strong>[<em>a</em>]</span>, comprises the following four fields:</p>
<dl>
<dt>nonce</dt>
<dd><p>A scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account. For account of address <span class="math inline"><em>a</em></span> in state <span class="math inline"><strong>σ</strong></span>, this would be formally denoted <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><em>n</em></sub></span>.</p>
</dd>
<dt>balance</dt>
<dd><p>A scalar value equal to the number of Wei owned by this address. Formally denoted <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><em>b</em></sub></span>.</p>
</dd>
<dt>storageRoot</dt>
<dd><p>A 256-bit hash of the root node of a Merkle Patricia tree that encodes the storage contents of the account (a mapping between 256-bit integer values), encoded into the trie as a mapping from the Keccak 256-bit hash of the 256-bit integer keys to the RLP-encoded 256-bit integer values. The hash is formally denoted <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><em>s</em></sub></span>.</p>
</dd>
<dt>codeHash</dt>
<dd><p>The hash of the EVM code of this account—this is the code that gets executed should this address receive a message call. All such code fragments are contained in the state database under their corresponding hashes for later retrieval. This hash is formally denoted <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><em>c</em></sub></span>, and thus the code may be denoted as <span class="math inline"><strong>b</strong></span>, given that <span class="math inline"><code>KEC</code>(<strong>b</strong>) = <strong>σ</strong>[<em>a</em>]<sub><em>c</em></sub></span>.</p>
</dd>
</dl>
<p>Since we typically wish to refer not to the trie’s root hash but to the underlying set of key/value pairs stored within, we define a convenient equivalence: <br /><span class="math display"><code>TRIE</code>(<em>L</em><sub><em>I</em></sub><sup>*</sup>(<strong>σ</strong>[<em>a</em>]<sub><strong>s</strong></sub>)) ≡ <strong>σ</strong>[<em>a</em>]<sub><em>s</em></sub></span><br /></p>
<p>The collapse function for the set of key/value pairs in the trie, <span class="math inline"><em>L</em><sub><em>I</em></sub><sup>*</sup></span>, is defined as the element-wise transformation of the base function <span class="math inline"><em>L</em><sub><em>I</em></sub></span>, given as: <br /><span class="math display"><em>L</em><sub><em>I</em></sub>((<em>k</em>, <em>v</em>)) ≡ (<code>KEC</code>(<em>k</em>), <code>RLP</code>(<em>v</em>))</span><br /></p>
<p>where: <br /><span class="math display"><em>k</em> ∈ 𝔹<sub>32</sub>  ∧  <em>v</em> ∈ ℕ</span><br /></p>
<p>It shall be understood that <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><strong>s</strong></sub></span> is not a ‘physical’ member of the account and does not contribute to its later serialisation.</p>
<p>If the <strong>codeHash</strong> field is the Keccak-256 hash of the empty string, i.e. <span class="math inline"><strong>σ</strong>[<em>a</em>]<sub><em>c</em></sub> = <code>KEC</code>(())</span>, then the node represents a simple account, sometimes referred to as a “non-contract” account.</p>
<p>Thus we may define a world-state collapse function <span class="math inline"><em>L</em><sub><em>S</em></sub></span>: <br /><span class="math display"><em>L</em><sub><em>S</em></sub>(<strong>σ</strong>) ≡ {<em>p</em>(<em>a</em>) : <strong>σ</strong>[<em>a</em>] ≠ ⌀}</span><br /> where <br /><span class="math display"><em>p</em>(<em>a</em>) ≡ (<code>KEC</code>(<em>a</em>), <code>RLP</code>((<strong>σ</strong>[<em>a</em>]<sub><em>n</em></sub>, <strong>σ</strong>[<em>a</em>]<sub><em>b</em></sub>, <strong>σ</strong>[<em>a</em>]<sub><em>s</em></sub>, <strong>σ</strong>[<em>a</em>]<sub><em>c</em></sub>)))</span><br /></p>
<p>This function, <span class="math inline"><em>L</em><sub><em>S</em></sub></span>, is used alongside the trie function to provide a short identity (hash) of the world state. We assume: <br /><span class="math display">∀<em>a</em> : <strong>σ</strong>[<em>a</em>] = ⌀ ∨ (<em>a</em> ∈ 𝔹<sub>20</sub> ∧ <em>v</em>(<strong>σ</strong>[<em>a</em>]))</span><br /> where <span class="math inline"><em>v</em></span> is the account validity function: <br /><span class="math display">  <em>v</em>(<em>x</em>) ≡ <em>x</em><sub><em>n</em></sub> ∈ ℕ<sub>256</sub> ∧ <em>x</em><sub><em>b</em></sub> ∈ ℕ<sub>256</sub> ∧ <em>x</em><sub><em>s</em></sub> ∈ 𝔹<sub>32</sub> ∧ <em>x</em><sub><em>c</em></sub> ∈ 𝔹<sub>32</sub></span><br /></p>
<p>An account is <em>empty</em> when it has no code, zero nonce and zero balance: <br /><span class="math display"><code>E</code><code>M</code><code>P</code><code>T</code><code>Y</code>(<strong>σ</strong>, <em>a</em>)  ≡  <strong>σ</strong>[<em>a</em>]<sub><em>c</em></sub> = <code>KEC</code>(()) ∧ <strong>σ</strong>[<em>a</em>]<sub><em>n</em></sub> = 0 ∧ <strong>σ</strong>[<em>a</em>]<sub><em>b</em></sub> = 0</span><br /> Even callable precompiled contracts can have an empty account state. This is because their account states do not usually contain the code describing its behavior.</p>
<p>An account is <em>dead</em> when its account state is non-existent or empty: <br /><span class="math display"><code>D</code><code>E</code><code>A</code><code>D</code>(<strong>σ</strong>, <em>a</em>)  ≡  <strong>σ</strong>[<em>a</em>] = ⌀ ∨ <code>E</code><code>M</code><code>P</code><code>T</code><code>Y</code>(<strong>σ</strong>, <em>a</em>)</span><br /></p>
<h2 id="subsec:transaction">The Transaction</h2>
<p>A transaction (formally, <span class="math inline"><em>T</em></span>) is a single cryptographically-signed instruction constructed by an actor externally to the scope of Ethereum. The sender of a transaction cannot be a contract. While it is assumed that the ultimate external actor will be human in nature, software tools will be used in its construction and dissemination<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. EIP-2718 by <span class="citation" data-cites="EIP-2718"></span> introduced the notion of different transaction types. As of the Berlin version of the protocol, there are two transaction types: 0 (legacy) and 1 (EIP-2930 by <span class="citation" data-cites="EIP-2930"></span>). Further, there are two subtypes of transactions: those which result in message calls and those which result in the creation of new accounts with associated code (known informally as ‘contract creation’). All transaction types specify a number of common fields:</p>
<dl>
<dt>type</dt>
<dd><p>EIP-2718 transaction type; formally <span class="math inline"><em>T</em><sub><em>x</em></sub></span>.</p>
</dd>
<dt>nonce</dt>
<dd><p>A scalar value equal to the number of transactions sent by the sender; formally <span class="math inline"><em>T</em><sub><em>n</em></sub></span>.</p>
</dd>
<dt>gasPrice</dt>
<dd><p>A scalar value equal to the number of Wei to be paid per unit of <em>gas</em> for all computation costs incurred as a result of the execution of this transaction; formally <span class="math inline"><em>T</em><sub><em>p</em></sub></span>.</p>
</dd>
<dt>gasLimit</dt>
<dd><p>A scalar value equal to the maximum amount of gas that should be used in executing this transaction. This is paid up-front, before any computation is done and may not be increased later; formally <span class="math inline"><em>T</em><sub><em>g</em></sub></span>.</p>
</dd>
<dt>to</dt>
<dd><p>The 160-bit address of the message call’s recipient or, for a contract creation transaction, <span class="math inline">⌀</span>, used here to denote the only member of <span class="math inline">𝔹<sub>0</sub></span> ; formally <span class="math inline"><em>T</em><sub><em>t</em></sub></span>.</p>
</dd>
<dt>value</dt>
<dd><p>A scalar value equal to the number of Wei to be transferred to the message call’s recipient or, in the case of contract creation, as an endowment to the newly created account; formally <span class="math inline"><em>T</em><sub><em>v</em></sub></span>.</p>
</dd>
<dt>r, s</dt>
<dd><p>Values corresponding to the signature of the transaction and used to determine the sender of the transaction; formally <span><span class="math inline"><em>T</em><sub><em>r</em></sub></span> and <span class="math inline"><em>T</em><sub><em>s</em></sub></span></span>. This is expanded in Appendix <a href="#app:signing" data-reference-type="ref" data-reference="app:signing">22</a>.</p>
</dd>
</dl>
<p>EIP-2930 (type 1) transactions also have:</p>
<dl>
<dt>accessList</dt>
<dd><p>List of access entries to warm up; formally <span class="math inline"><em>T</em><sub><strong>A</strong></sub></span>. Each access list entry <span class="math inline"><em>E</em></span> is a tuple of an account address and a list of storage keys: <span class="math inline"><em>E</em> ≡ (<em>E</em><sub><em>a</em></sub>, <em>E</em><sub><strong>s</strong></sub>)</span>.</p>
</dd>
<dt>chainId</dt>
<dd><p>Chain ID; formally <span class="math inline"><em>T</em><sub><em>c</em></sub></span>. Must be equal to the network chain ID <a href="#chain_id"><span class="math inline"><em>β</em></span></a>.</p>
</dd>
<dt>yParity</dt>
<dd><p>Signature Y parity; formally <span class="math inline"><em>T</em><sub><em>y</em></sub></span>.</p>
</dd>
</dl>
<p>Legacy transactions do not have an <strong>accessList</strong> (<span class="math inline"><em>T</em><sub><strong>A</strong></sub> = ()</span>), while <strong>chainId</strong> and <strong>yParity</strong> for legacy transactions are combined into a single value:</p>
<dl>
<dt>w</dt>
<dd><p>A scalar value encoding Y parity and possibly chain ID; formally <span class="math inline"><em>T</em><sub><em>w</em></sub></span>. <span class="math inline"><em>T</em><sub><em>w</em></sub> = 27 + <em>T</em><sub><em>y</em></sub></span> or <span class="math inline"><em>T</em><sub><em>w</em></sub> = 2<em>β</em> + 35 + <em>T</em><sub><em>y</em></sub></span> (see EIP-155 by <span class="citation" data-cites="EIP-155"></span>).</p>
</dd>
</dl>
<p>Additionally, a contract creation transaction (regardless whether legacy or EIP-2930) contains:</p>
<dl>
<dt>init</dt>
<dd><p>An unlimited size byte array specifying the EVM-code for the account initialisation procedure, formally <span class="math inline"><em>T</em><sub><strong>i</strong></sub></span>.</p>
</dd>
</dl>
<p><strong>init</strong> is an EVM-code fragment; it returns the <strong>body</strong>, a second fragment of code that executes each time the account receives a message call (either through a transaction or due to the internal execution of code). <strong>init</strong> is executed only once at account creation and gets discarded immediately thereafter.</p>
<p>In contrast, a message call transaction contains:</p>
<dl>
<dt>data</dt>
<dd><p>An unlimited size byte array specifying the input data of the message call, formally <span class="math inline"><em>T</em><sub><strong>d</strong></sub></span>.</p>
</dd>
</dl>
<p>Appendix <a href="#app:signing" data-reference-type="ref" data-reference="app:signing">22</a> specifies the function, <span class="math inline"><em>S</em></span>, which maps transactions to the sender, and happens through the ECDSA of the SECP-256k1 curve, using the hash of the transaction (excepting the latter three signature fields) as the datum to sign. For the present we simply assert that the sender of a given transaction <span class="math inline"><em>T</em></span> can be represented with <span class="math inline"><em>S</em>(<em>T</em>)</span>.</p>
<p><br /><span class="math display">$$\Hy@raisedlink{\hypertarget{L_transaction}{}} L_{\mathrm{T}}(T) \equiv \begin{cases}
(T_{\mathrm{n}}, T_{\mathrm{p}}, T_{\mathrm{g}}, T_{\mathrm{t}}, T_{\mathrm{v}}, \mathbf{p}, T_{\mathrm{w}}, T_{\mathrm{r}}, T_{\mathrm{s}}) &amp; \text{if} \; T_{\mathrm{x}} = 0 \\
(T_{\mathrm{c}}, T_{\mathrm{n}}, T_{\mathrm{p}}, T_{\mathrm{g}}, T_{\mathrm{t}}, T_{\mathrm{v}}, \mathbf{p}, T_{\mathbf{A}}, T_{\mathrm{y}}, T_{\mathrm{r}}, T_{\mathrm{s}}) &amp; \text{if} \; T_{\mathrm{x}} = 1 \\
\end{cases}$$</span><br /> where <br /><span class="math display">$$\mathbf{p} \equiv \begin{cases}
T_{\mathbf{i}} &amp; \text{if}\ T_{\mathrm{t}} = \varnothing \\
T_{\mathbf{d}} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>Here, we assume all components are interpreted by the RLP as integer values, with the exception of the access list <span class="math inline"><em>T</em><sub><strong>A</strong></sub></span> and the arbitrary length byte arrays <span class="math inline"><em>T</em><sub><strong>i</strong></sub></span> and <span class="math inline"><em>T</em><sub><strong>d</strong></sub></span>. <br /><span class="math display">$$\begin{array}[t]{lclclc}
T_{\mathrm{x}} \in \{0, 1\} &amp; \wedge &amp; T_{\mathrm{c}} = \beta &amp; \wedge &amp; T_{\mathrm{n}} \in \mathbb{N}_{256} &amp; \wedge \\
T_{\mathrm{p}} \in \mathbb{N}_{256} &amp; \wedge &amp; T_{\mathrm{g}} \in \mathbb{N}_{256} &amp; \wedge &amp; T_{\mathrm{v}} \in \mathbb{N}_{256} &amp; \wedge \\
T_{\mathrm{w}} \in \mathbb{N}_{256} &amp; \wedge &amp; T_{\mathrm{r}} \in \mathbb{N}_{256} &amp; \wedge &amp; T_{\mathrm{s}} \in \mathbb{N}_{256} &amp; \wedge \\
T_{\mathrm{y}} \in \mathbb{N}_{1} &amp; \wedge &amp; T_{\mathbf{d}} \in \mathbb{B} &amp; \wedge &amp; T_{\mathbf{i}} \in \mathbb{B}
\end{array}$$</span><br /> where <br /><span class="math display">ℕ<sub><em>n</em></sub> = {<em>P</em> : <em>P</em> ∈ ℕ ∧ <em>P</em> &lt; 2<sup><em>n</em></sup>}</span><br /></p>
<p>The address hash <span class="math inline"><em>T</em><sub><strong>t</strong></sub></span> is slightly different: it is either a 20-byte address hash or, in the case of being a contract-creation transaction (and thus formally equal to <span class="math inline">⌀</span>), it is the RLP empty byte sequence and thus the member of <span class="math inline">𝔹<sub>0</sub></span>: <br /><span class="math display">$$T_{\mathbf{t}} \in \begin{cases} \mathbb{B}_{20} &amp; \text{if} \quad T_{\mathrm{t}} \neq \varnothing \\
\mathbb{B}_{0} &amp; \text{otherwise}\end{cases}$$</span><br /></p>
<h2 id="the-block">The Block</h2>
<p><span id="subsec:The_Block" label="subsec:The_Block">[subsec:The_Block]</span></p>
<p>The block in Ethereum is the collection of relevant pieces of information (known as the block <em>header</em>), <span class="math inline"><em>H</em></span>, together with information corresponding to the comprised transactions, <span class="math inline"><strong>T</strong></span>,<span id="ommerheaders"></span> and a set of other block headers <span class="math inline"><strong>U</strong></span> that are known to have a parent equal to the present block’s parent’s parent (such blocks are known as <em>ommers</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>). The block header contains several pieces of information:</p>
<dl>
<dt>parentHash</dt>
<dd><p>The Keccak 256-bit hash of the parent block’s header, in its entirety; formally <span class="math inline"><em>H</em><sub><em>p</em></sub></span>.</p>
</dd>
<dt>ommersHash</dt>
<dd><p>The Keccak 256-bit hash of the ommers list portion of this block; formally <span class="math inline"><em>H</em><sub><em>o</em></sub></span>.</p>
</dd>
<dt>beneficiary</dt>
<dd><p>The 160-bit address to which all fees collected from the successful mining of this block be transferred; formally <span class="math inline"><em>H</em><sub><em>c</em></sub></span>.</p>
</dd>
<dt>stateRoot</dt>
<dd><p>The Keccak 256-bit hash of the root node of the state trie, after all transactions are executed and finalisations applied; formally <span class="math inline"><em>H</em><sub><em>r</em></sub></span>.</p>
</dd>
<dt>transactionsRoot</dt>
<dd><p>The Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transactions list portion of the block; formally <span class="math inline"><em>H</em><sub><em>t</em></sub></span>.</p>
</dd>
<dt>receiptsRoot</dt>
<dd><p>The Keccak 256-bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block; formally <span class="math inline"><em>H</em><sub><em>e</em></sub></span>.</p>
</dd>
<dt>logsBloom</dt>
<dd><p>The Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list; formally <span class="math inline"><em>H</em><sub><em>b</em></sub></span>.</p>
</dd>
<dt>difficulty</dt>
<dd><p>A scalar value corresponding to the difficulty level of this block. This can be calculated from the previous block’s difficulty level and the timestamp; formally <span class="math inline"><em>H</em><sub><em>d</em></sub></span>.</p>
</dd>
<dt>number</dt>
<dd><p>A scalar value equal to the number of ancestor blocks. The genesis block has a number of zero; formally <a href="#block_number_H__i"><span class="math inline"><em>H</em><sub><em>i</em></sub></span></a>.</p>
</dd>
<dt>gasLimit</dt>
<dd><p>A scalar value equal to the current limit of gas expenditure per block; formally <span class="math inline"><em>H</em><sub><em>l</em></sub></span>.</p>
</dd>
<dt>gasUsed</dt>
<dd><p>A scalar value equal to the total gas used in transactions in this block; formally <span class="math inline"><em>H</em><sub><em>g</em></sub></span>.</p>
</dd>
<dt>timestamp</dt>
<dd><p>A scalar value equal to the reasonable output of Unix’s time() at this block’s inception; formally <a href="#block_timestamp_H__s"><span class="math inline"><em>H</em><sub><em>s</em></sub></span></a>.</p>
</dd>
<dt>extraData</dt>
<dd><p>An arbitrary byte array containing data relevant to this block. This must be 32 bytes or fewer; formally <span class="math inline"><em>H</em><sub><em>x</em></sub></span>.</p>
</dd>
<dt>mixHash</dt>
<dd><p>A 256-bit hash which, combined with the nonce, proves that a sufficient amount of computation has been carried out on this block; formally <span class="math inline"><em>H</em><sub><em>m</em></sub></span>.</p>
</dd>
<dt>nonce</dt>
<dd><p>A 64-bit value which, combined with the mix-hash, proves that a sufficient amount of computation has been carried out on this block; formally <a href="#H__n"><span class="math inline"><em>H</em><sub><em>n</em></sub></span></a>.</p>
</dd>
</dl>
<p>The other two components in the block are simply a list of ommer block headers (of the same format as above), <span class="math inline"><em>B</em><sub><strong>U</strong></sub></span> and a series of the transactions, <span class="math inline"><em>B</em><sub><strong>T</strong></sub></span>. Formally, we can refer to a block <span class="math inline"><em>B</em></span>: <br /><span class="math display"><em>B</em> ≡ (<em>B</em><sub><em>H</em></sub>, <em>B</em><sub><strong>T</strong></sub>, <em>B</em><sub><strong>U</strong></sub>)</span><br /></p>
<h3 id="transaction-receipt">Transaction Receipt</h3>
<p>In order to encode information about a transaction concerning which it may be useful to form a zero-knowledge proof, or index and search, we encode a receipt of each transaction containing certain information from its execution. Each receipt, denoted <span class="math inline"><em>B</em><sub><strong>R</strong></sub>[<em>i</em>]</span> for the <span class="math inline"><em>i</em></span>th transaction, is placed in an index-keyed <a href="#trie">trie</a> and the root recorded in the header as <a href="#Receipts_Root_H__e"><span class="math inline"><em>H</em><sub><em>e</em></sub></span></a>.</p>
<p>The transaction receipt, <span class="math inline"><em>R</em></span>, is a tuple of five items comprising: the type of the transaction, <span class="math inline"><em>R</em><sub><em>x</em></sub></span>, the status code of the transaction, <span class="math inline"><em>R</em><sub><em>z</em></sub></span>, the cumulative gas used in the block containing the transaction receipt as of immediately after the transaction has happened, <span class="math inline"><em>R</em><sub><em>u</em></sub></span>, the set of logs created through execution of the transaction, <a href="#RLP_serialisation_of_a_sequence_of_other_items_R__l_math_def"><span class="math inline"><em>R</em><sub><strong>l</strong></sub></span></a> and the Bloom filter composed from information in those logs, <a href="#RLP_serialisation_of_a_byte_array_R__b_math_def"><span class="math inline"><em>R</em><sub><em>b</em></sub></span></a>: <br /><span class="math display"><em>R</em> ≡ (<em>R</em><sub><em>x</em></sub>, <em>R</em><sub><em>z</em></sub>, <em>R</em><sub><em>u</em></sub>, <em>R</em><sub><em>b</em></sub>, <em>R</em><sub><strong>l</strong></sub>)</span><br /></p>
<p><span class="math inline"><em>R</em><sub><em>x</em></sub></span> is equal to the <a href="#tx_type">type</a> of the corresponding transaction.</p>
<p>The function <span class="math inline"><em>L</em><sub><em>R</em></sub></span> prepares a transaction receipt for being transformed into an RLP-serialised byte array: <br /><span class="math display"><em>L</em><sub><em>R</em></sub>(<em>R</em>) ≡ (<em>R</em><sub><em>z</em></sub>, <em>R</em><sub><em>u</em></sub>, <em>R</em><sub><em>b</em></sub>, <em>R</em><sub><strong>l</strong></sub>)</span><br /></p>
<p>We assert that the status code <span class="math inline"><em>R</em><sub><em>z</em></sub></span> is a non-negative integer: <br /><span class="math display"><em>R</em><sub><em>z</em></sub> ∈ ℕ</span><br /></p>
<p>We assert that <span class="math inline"><em>R</em><sub><em>u</em></sub></span>, the cumulative gas used, is a non-negative integer and that the logs Bloom, <span class="math inline"><em>R</em><sub><em>b</em></sub></span>, is a hash of size 2048 bits (256 bytes): <br /><span class="math display"><em>R</em><sub><em>u</em></sub> ∈ ℕ  ∧  <em>R</em><sub><em>b</em></sub> ∈ 𝔹<sub>256</sub></span><br /></p>
<p>The sequence <span class="math inline"><em>R</em><sub><strong>l</strong></sub></span> is a series of log entries, <span class="math inline">(<em>O</em><sub>0</sub>, <em>O</em><sub>1</sub>, ...)</span>. A log entry, <span class="math inline"><em>O</em></span>, is a tuple of the logger’s address, <span class="math inline"><em>O</em><sub><em>a</em></sub></span>, a possibly empty series of 32-byte log topics, <span class="math inline"><em>O</em><sub><strong>t</strong></sub></span> and some number of bytes of data, <span class="math inline"><em>O</em><sub><strong>d</strong></sub></span>: <br /><span class="math display"><em>O</em> ≡ (<em>O</em><sub><em>a</em></sub>, (<em>O</em><sub><strong>t</strong></sub><sub>0</sub>, <em>O</em><sub><strong>t</strong></sub><sub>1</sub>, ...), <em>O</em><sub><strong>d</strong></sub>)</span><br /> <br /><span class="math display"><em>O</em><sub><em>a</em></sub> ∈ 𝔹<sub>20</sub>  ∧  ∀<em>x</em> ∈ <em>O</em><sub><strong>t</strong></sub> : <em>x</em> ∈ 𝔹<sub>32</sub>  ∧  <em>O</em><sub><strong>d</strong></sub> ∈ 𝔹</span><br /></p>
<p>We define the Bloom filter function, <span class="math inline"><em>M</em></span>, to reduce a log entry into a single 256-byte hash: <br /><span class="math display">$$M(O) \equiv \hyperlink{bigvee}{\bigvee}_{x \in \{O_{\mathrm{a}}\} \cup O_{\mathbf{t}}} \big( M_{3:2048}(x) \big)$$</span><br /> where <span class="math inline"><em>M</em><sub>3 : 2048</sub></span> is a specialised Bloom filter that sets three bits out of 2048, given an arbitrary byte sequence. It does this through taking the low-order 11 bits of each of the first three pairs of bytes in a Keccak-256 hash of the byte sequence.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Formally: <br /><span class="math display">$$\begin{aligned}
M_{3:2048}(\mathbf{x}: \mathbf{x} \in \mathbb{B}) &amp; \equiv &amp; \mathbf{y}: \mathbf{y} \in \mathbb{B}_{256} \quad \text{where:}\\
\mathbf{y} &amp; = &amp; (0, 0, ..., 0) \quad \text{except:}\\
\forall i \in \{0, 2, 4\}&amp;:&amp;\mathcal{B}_{2047 - m(\mathbf{x}, i)}(\mathbf{y}) = 1\\
m(\mathbf{x}, i) &amp;\equiv&amp; \mathtt{KEC}(\mathbf{x})[i, i + 1] \bmod 2048\end{aligned}$$</span><br /> where <span class="math inline">ℬ</span> is the bit reference function such that <span class="math inline">ℬ<sub><em>j</em></sub>(<strong>x</strong>)</span> equals the bit of index <span class="math inline"><em>j</em></span> (indexed from 0) in the byte array <span class="math inline"><strong>x</strong></span>. Notably, it treats <span class="math inline"><strong>x</strong></span> as big-endian (more significant bits will have smaller indices).</p>
<h3 id="holistic-validity">Holistic Validity</h3>
<p>We can assert a block’s validity if and only if it satisfies several conditions: it must be internally consistent with the ommer and transaction block hashes and the given transactions <span class="math inline"><em>B</em><sub><strong>T</strong></sub></span> (as specified in sec <a href="#ch:finalisation" data-reference-type="ref" data-reference="ch:finalisation">11</a>), when executed in order on the base state <span class="math inline"><strong>σ</strong></span> (derived from the final state of the parent block), result in a new state of the identity <span class="math inline"><em>H</em><sub><em>r</em></sub></span>: <br /><span class="math display">$$\begin{array}[t]{lclc}
\Hy@raisedlink{\hypertarget{new_state_H__r}{}}{}H_{\mathrm{r}} &amp;\equiv&amp; \mathtt{TRIE}(L_S(\Pi(\boldsymbol{\sigma}, B))) &amp; \wedge \\
\Hy@raisedlink{\hypertarget{Ommer_block_hash_H__o}{}}{}H_{\mathrm{o}} &amp;\equiv&amp; \mathtt{KEC}(\mathtt{RLP}(L_H^*(B_{\mathbf{U}}))) &amp; \wedge \\
\Hy@raisedlink{\hypertarget{tx_block_hash_H__t}{}}{}H_{\mathrm{t}} &amp;\equiv&amp; \mathtt{TRIE}(\{\forall i &lt; \lVert B_{\mathbf{T}} \rVert, i \in \mathbb{N}: &amp;\\&amp;&amp; \quad\quad p_{\mathrm{T}}(i, B_{\mathbf{T}}[i])\}) &amp; \wedge \\
\Hy@raisedlink{\hypertarget{Receipts_Root_H__e}{}}{}H_{\mathrm{e}} &amp;\equiv&amp; \mathtt{TRIE}(\{\forall i &lt; \lVert B_{\mathbf{R}} \rVert, i \in \mathbb{N}: &amp;\\&amp;&amp; \quad\quad p_{\mathrm{R}}(i, B_{\mathbf{R}}[i])\}) &amp; \wedge \\
\Hy@raisedlink{\hypertarget{logs_Bloom_filter_H__b}{}}{}H_{\mathrm{b}} &amp;\equiv&amp; \bigvee_{\mathbf{r} \in B_{\mathbf{R}}} \big( \mathbf{r}_{\mathrm{b}} \big)
\end{array}$$</span><br /> where <span class="math inline"><em>p</em><sub><em>T</em></sub>(<em>k</em>, <em>v</em>)</span> and <span class="math inline"><em>p</em><sub><em>R</em></sub>(<em>k</em>, <em>v</em>)</span> are pairwise RLP transformations, but with a special treatment for EIP-2718 transactions: <br /><span class="math display">$$p_{\mathrm{T}}(k, T) \equiv \left( \mathtt{RLP}(k), \begin{cases}
\mathtt{RLP}(\hyperlink{L_transaction}{L_{\mathrm{T}}}(T)) &amp; \text{if} \quad T_{\mathrm{x}} = 0 \\
(T_{\mathrm{x}}) \cdot \mathtt{RLP}(L_{\mathrm{T}}(T)) &amp; \text{otherwise}
\end{cases}
\right)$$</span><br /> and <br /><span class="math display">$$p_{\mathrm{R}}(k, R) \equiv \left( \mathtt{RLP}(k), \begin{cases}
\mathtt{RLP}(\hyperlink{L__R}{L_{\mathrm{R}}}(R)) &amp; \text{if} \quad R_{\mathrm{x}} = 0 \\
(R_{\mathrm{x}}) \cdot \mathtt{RLP}(L_{\mathrm{R}}(R)) &amp; \text{otherwise}
\end{cases}
\right)$$</span><br /> (<span class="math inline">⋅</span> is the concatenation of byte arrays).</p>
<p>Furthermore: <br /><span class="math display"><code>T</code><code>R</code><code>I</code><code>E</code>(<em>L</em><sub><em>S</em></sub>(<strong>σ</strong>)) = <em>P</em>(<em>B</em><sub><em>H</em></sub>)<sub><em>H</em></sub><sub><em>r</em></sub></span><br /></p>
<p>Thus <span class="math inline"><code>TRIE</code>(<em>L</em><sub><em>S</em></sub>(<strong>σ</strong>))</span> is the root node hash of the Merkle Patricia tree structure containing the key-value pairs of the state <span class="math inline"><strong>σ</strong></span> with values encoded using RLP, and <span class="math inline"><em>P</em>(<em>B</em><sub><em>H</em></sub>)</span> is the parent block of <span class="math inline"><em>B</em></span>, defined directly.</p>
<p>The values stemming from the computation of transactions, specifically the <a href="#Transaction_Receipt">transaction receipts</a>, <span class="math inline"><em>B</em><sub><strong>R</strong></sub></span>, and that defined through the transaction’s <a href="#Pi">state-accumulation function, <span class="math inline"><em>Π</em></span></a>, are formalised later in section <a href="#sec:statenoncevalidation" data-reference-type="ref" data-reference="sec:statenoncevalidation">11.4</a>.</p>
<h3 id="serialisation">Serialisation</h3>
<div id="block_preparation_function_for_RLP_serialization_L__B">

</div>
<p><span id="block_preparation_function_for_RLP_serialization_L__H"></span>The function <span class="math inline"><em>L</em><sub><em>B</em></sub></span> and <span class="math inline"><em>L</em><sub><em>H</em></sub></span> are the preparation functions for a block and block header respectively. We assert the types and order of the structure for when the RLP transformation is required: <br /><span class="math display">$$\begin{aligned}
\quad L_{\mathrm{H}}(H) &amp; \equiv &amp; (\begin{array}[t]{l}H_{\mathrm{p}}, H_{\mathrm{o}}, H_{\mathrm{c}}, H_{\mathrm{r}}, H_{\mathrm{t}}, H_{\mathrm{e}}, H_{\mathrm{b}}, H_{\mathrm{d}},\\ H_{\mathrm{i}}, H_{\mathrm{l}}, H_{\mathrm{g}}, H_{\mathrm{s}}, H_{\mathrm{x}}, H_{\mathrm{m}}, H_{\mathrm{n}} \; )\end{array} \\
\quad L_{\mathrm{B}}(B) &amp; \equiv &amp; \big( L_{\mathrm{H}}(B_{\mathrm{H}}), \widetilde{L}_{\mathrm{T}}^*(B_{\mathbf{T}}), L_{\mathrm{H}}^*(\hyperlink{ommer_block_headers_B__U}{B_{\mathbf{U}}}) \big)\end{aligned}$$</span><br /> where <span class="math inline"><em>L̃</em><sub><em>T</em></sub></span> takes a special care of EIP-2718 transactions: <br /><span class="math display">$$\widetilde{L}_{\mathrm{T}}(T) = \begin{cases}
\hyperlink{L_transaction}{L_{\mathrm{T}}}(T) &amp; \text{if} \quad T_{\mathrm{x}} = 0 \\
(T_{\mathrm{x}}) \cdot \mathtt{RLP}(L_{\mathrm{T}}(T)) &amp; \text{otherwise}
\end{cases}$$</span><br /> <span id="general_element_wise_sequence_transformation_f_pow_asterisk"></span>with <span class="math inline"><em>L̃</em><sub><em>T</em></sub><sup>*</sup></span> and <span class="math inline"><em>L</em><sub><em>H</em></sub><sup>*</sup></span> being element-wise sequence transformations, thus: <br /><span class="math display"><em>f</em><sup>*</sup>((<em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, ...)) ≡ (<em>f</em>(<em>x</em><sub>0</sub>), <em>f</em>(<em>x</em><sub>1</sub>), ...)  for any function <em>f</em></span><br /></p>
<p>The component types are defined thus: <br /><span class="math display">$$\begin{array}[t]{lclclcl}
\hyperlink{parent_Hash_H__p_def_words}{H_{\mathrm{p}}} \in \mathbb{B}_{32} &amp; \wedge &amp; H_{\mathrm{o}} \in \mathbb{B}_{32} &amp; \wedge &amp; H_{\mathrm{c}} \in \mathbb{B}_{20} &amp; \wedge \\
\hyperlink{new_state_H__r}{H_{\mathrm{r}}} \in \mathbb{B}_{32} &amp; \wedge &amp; H_{\mathrm{t}} \in \mathbb{B}_{32} &amp; \wedge &amp; \hyperlink{Receipts_Root_H__e}{H_{\mathrm{e}}} \in \mathbb{B}_{32} &amp; \wedge \\
\hyperlink{logs_Bloom_filter_H__b}{H_{\mathrm{b}}} \in \mathbb{B}_{256} &amp; \wedge &amp; H_{\mathrm{d}} \in \mathbb{N} &amp; \wedge &amp; \hyperlink{block_number_H__i}{H_{\mathrm{i}}} \in \mathbb{N} &amp; \wedge \\
\hyperlink{block_gas_limit_H__l}{H_{\mathrm{l}}} \in \mathbb{N} &amp; \wedge &amp; H_{\mathrm{g}} \in \mathbb{N} &amp; \wedge &amp; \hyperlink{block_timestamp_H__s}{H_{\mathrm{s}}} \in \mathbb{N}_{256} &amp; \wedge \\
\hyperlink{block_extraData_H__x}{H_{\mathrm{x}}} \in \mathbb{B} &amp; \wedge &amp; H_{\mathrm{m}} \in \mathbb{B}_{32} &amp; \wedge &amp; \hyperlink{block_nonce_H__n}{H_{\mathrm{n}}} \in \mathbb{B}_{8}
\end{array}$$</span><br /></p>
<p>where <br /><span class="math display">𝔹<sub><em>n</em></sub> = {<em>B</em> : <em>B</em> ∈ 𝔹 ∧ ∥<em>B</em>∥ = <em>n</em>}</span><br /></p>
<p>We now have a rigorous specification for the construction of a formal block structure. The RLP function <span class="math inline"><code>RLP</code></span> (see Appendix <a href="#app:rlp" data-reference-type="ref" data-reference="app:rlp">18</a>) provides the canonical method for transforming this structure into a sequence of bytes ready for transmission over the wire or storage locally.</p>
<h3 id="block-header-validity">Block Header Validity</h3>
<p>We define <span class="math inline"><em>P</em>(<em>B</em><sub><em>H</em></sub>)</span> to be the parent block of <span class="math inline"><em>B</em></span>, formally: <br /><span class="math display">$$P(H) \equiv B': \mathtt{KEC}(\mathtt{RLP}(B'_{\mathrm{H}})) = \hyperlink{parent_Hash_H__p_def_words}{H_{\mathrm{p}}}$$</span><br /></p>
<div id="block_number_H__i">

</div>
<p>The block number is the parent’s block number incremented by one: <br /><span class="math display"><em>H</em><sub><em>i</em></sub> ≡ <em>P</em>(<em>H</em>)<sub><em>H</em></sub><sub><em>i</em></sub> + 1</span><br /></p>
<div id="block_difficulty_H__d">

</div>
<p>The canonical difficulty of a block of header <span class="math inline"><em>H</em></span> is defined as <span class="math inline"><em>D</em>(<em>H</em>)</span>: <br /><span class="math display">$$D(H) \equiv \begin{dcases}
2^{34} &amp; \text{if} \quad H_{\mathrm{i}} = 0\\
\text{max}\!\left(D_\mathrm{min}, {P(H)_{\mathrm{H}}}_{\mathrm{d}} + x\times\ensuremath{\varsigma_2}+ \ensuremath{\epsilon}\right) &amp; \text{otherwise}\\
\end{dcases}$$</span><br /> where: <br /><span class="math display">$$\begin{aligned}
D_\mathrm{min}&amp;\equiv 2^{17} \\
x&amp;\equiv \left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{d}}}{2048}\right\rfloor \\
\ensuremath{\varsigma_2}&amp;\equiv \text{max}\left( y - \left\lfloor\frac{H_{\mathrm{s}} - {P(H)_{\mathrm{H}}}_{\mathrm{s}}}{9}\right\rfloor, -99 \right) \\
y &amp;\equiv \begin{cases}
1 &amp; \text{if} \quad \lVert P(H)_{\mathbf{U}}\rVert = 0 \\
2 &amp; \text{otherwise}
\end{cases} \\
\ensuremath{\epsilon}&amp;\equiv \left\lfloor 2^{ \left\lfloor H'_{\mathrm{i}} \div 100000 \right\rfloor - 2 } \right\rfloor \\
H'_{\mathrm{i}} &amp;\equiv \max(H_{\mathrm{i}} - \kappa, 0)\end{aligned}$$</span><br /> <br /><span class="math display">$$\kappa \equiv \begin{cases} 
  3000000  &amp; \text{if} \quad F_{\mathrm{Byzantium}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{Constantinople}} \\
  5000000  &amp; \text{if} \quad F_{\mathrm{Constantinople}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{Muir Glacier}} \\
  9000000  &amp; \text{if} \quad F_{\mathrm{Muir Glacier}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{London}} \\
  9700000  &amp; \text{if} \quad F_{\mathrm{London}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{Arrow Glacier}} \\
 10700000  &amp; \text{if} \quad F_{\mathrm{Arrow Glacier}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{Gray Glacier}} \\
 11400000  &amp; \text{if} \quad H_{\mathrm{i}} \geqslant F_{\mathrm{Gray Glacier}} \\
\end{cases}$$</span><br /></p>
<p>The <em>Homestead</em> difficulty parameter, <span class="math inline">ς<sub>2</sub></span>, is used to affect a dynamic homeostasis of time between blocks, as the time between blocks varies, as discussed below, as implemented in EIP-2 by <span class="citation" data-cites="EIP-2"></span>. In the Homestead release, the exponential difficulty symbol, <span class="math inline"><em>ϵ</em></span> causes the difficulty to slowly increase (every 100,000 blocks) at an exponential rate, and thus increasing the block time difference, and putting time pressure on transitioning to proof-of-stake. This effect, known as the "difficulty bomb", or "ice age", was explained in EIP-649 by <span class="citation" data-cites="EIP-649"></span> and delayed and implemented earlier in EIP-2. <span class="math inline">ς<sub>2</sub></span> was also modified in EIP-100 with the use of <span class="math inline"><em>x</em></span>, the adjustment factor above, and the denominator 9, in order to target the mean block time including uncle blocks by <span class="citation" data-cites="EIP-100"></span>. In the <em>Byzantium</em> release, with EIP-649, the ice age was delayed by creating a fake block number, <span class="math inline"><em>H</em>′<sub><em>i</em></sub></span>, which is obtained by subtracting three million from the actual block number, which in other words reduced <span class="math inline"><em>ϵ</em></span> and the time difference between blocks, in order to allow more time to develop proof-of-stake and preventing the network from "freezing" up. Subsequently, EIP-1234 by <span class="citation" data-cites="EIP-1234"></span>, EIP-2384 by <span class="citation" data-cites="EIP-2384"></span>, EIP-3554 by <span class="citation" data-cites="EIP-3554"></span>, EIP-4345 by <span class="citation" data-cites="EIP-4345"></span>, and EIP-5133 by <span class="citation" data-cites="EIP-5133"></span> increased the subtrahend <span class="math inline"><em>κ</em></span>.</p>
<div id="block_gas_limit_H__l">

</div>
<p>The canonical gas limit <span class="math inline"><em>H</em><sub><em>l</em></sub></span> of a block of header <span class="math inline"><em>H</em></span> must fulfil the relation: <br /><span class="math display">$$\begin{aligned}
&amp; &amp; H_{\mathrm{l}} &lt; {P(H)_{\mathrm{H}}}_{\mathrm{l}} + \left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{l}}}{1024}\right\rfloor \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{l}} &gt; {P(H)_{\mathrm{H}}}_{\mathrm{l}} - \left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{l}}}{1024}\right\rfloor \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{l}} \geqslant 5000\end{aligned}$$</span><br /></p>
<div id="block_timestamp_H__s">

</div>
<p><span class="math inline"><em>H</em><sub><em>s</em></sub></span> is the timestamp (in Unix’s time()) of block <span class="math inline"><em>H</em></span> and must fulfil the relation: <br /><span class="math display"><em>H</em><sub><em>s</em></sub> &gt; <em>P</em>(<em>H</em>)<sub><em>H</em></sub><sub><em>s</em></sub></span><br /></p>
<p>This mechanism enforces a homeostasis in terms of the time between blocks; a smaller period between the last two blocks results in an increase in the difficulty level and thus additional computation required, lengthening the likely next period. Conversely, if the period is too large, the difficulty, and expected time to the next block, is reduced.</p>
<p>The nonce, <a href="#block_nonce_H__n"><span class="math inline"><em>H</em><sub><em>n</em></sub></span></a>, must satisfy the relations: <br /><span class="math display">$$n \leqslant \frac{2^{256}}{H_{\mathrm{d}}} \quad \wedge \quad m = H_{\mathrm{m}}$$</span><br /> with <span class="math inline">$(n, m) = \mathtt{PoW}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}, H_{\mathrm{n}}, \mathbf{d})$</span>.</p>
<div id="block_header_without_nonce_and_mixmash_h__cancel_n">

</div>
<p>Where <span class="math inline">$H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}$</span> is the new block’s header <span class="math inline"><em>H</em></span>, but <em>without</em> the nonce and mix-hash components, <span class="math inline"><strong>d</strong></span> being the current DAG, a large data set needed to compute the mix-hash, and <span class="math inline"><code>P</code><code>o</code><code>W</code></span> is the proof-of-work function (see section <a href="#ch:pow" data-reference-type="ref" data-reference="ch:pow">11.5</a>): this evaluates to an array with the first item being the mix-hash, to prove that a correct DAG has been used, and the second item being a pseudo-random number cryptographically dependent on <span class="math inline"><em>H</em></span> and <span class="math inline"><strong>d</strong></span>. Given an approximately uniform distribution in the range <span class="math inline">[0, 2<sup>64</sup>)</span>, the expected time to find a solution is proportional to the difficulty, <span class="math inline"><em>H</em><sub><em>d</em></sub></span>.</p>
<p>This is the foundation of the security of the blockchain and is the fundamental reason why a malicious node cannot propagate newly created blocks that would otherwise overwrite (“rewrite”) history. Because the nonce must satisfy this requirement, and because its satisfaction depends on the contents of the block and in turn its composed transactions, creating new, valid, blocks is difficult and, over time, requires approximately the total compute power of the trustworthy portion of the mining peers.</p>
<div id="block_header_validity_function">

</div>
<p>Thus we are able to define the block header validity function <span class="math inline"><em>V</em>(<em>H</em>)</span>: <br /><span class="math display">$$\begin{aligned}
V(H) &amp; \equiv &amp;  n \leqslant \frac{2^{256}}{H_{\mathrm{d}}} \wedge m = H_{\mathrm{m}} \quad \wedge \\
\nonumber &amp; &amp; H_{\mathrm{d}} = D(H) \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{g}} \le H_{\mathrm{l}}  \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{l}} &lt; {P(H)_{\mathrm{H}}}_{\mathrm{l}} + \left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{l}}}{1024}\right\rfloor  \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{l}} &gt; {P(H)_{\mathrm{H}}}_{\mathrm{l}} - \left\lfloor\frac{{P(H)_{\mathrm{H}}}_{\mathrm{l}}}{1024}\right\rfloor  \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{l}} \geqslant 5000  \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{s}} &gt; {P(H)_{\mathrm{H}}}_{\mathrm{s}} \quad \wedge \\
\nonumber&amp; &amp; H_{\mathrm{i}} = {P(H)_{\mathrm{H}}}_{\mathrm{i}} +1 \quad \wedge \\
\nonumber&amp; &amp; \lVert H_{\mathrm{x}} \rVert \le 32\end{aligned}$$</span><br /> where <span class="math inline">$(n, m) = \mathtt{PoW}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}, H_{\mathrm{n}}, \mathbf{d})$</span></p>
<p>Noting additionally that <strong>extraData</strong> must be at most 32 bytes.</p>
<h1 id="ch:payment">Gas and Payment</h1>
<p>In order to avoid issues of network abuse and to sidestep the inevitable questions stemming from Turing completeness, all programmable computation in Ethereum is subject to fees. The fee schedule is specified in units of <em>gas</em> (see Appendix <a href="#app:fees" data-reference-type="ref" data-reference="app:fees">23</a> for the fees associated with various computation). Thus any given fragment of programmable computation (this includes creating contracts, making message calls, utilising and accessing account storage and executing operations on the virtual machine) has a universally agreed cost in terms of gas.</p>
<p>Every transaction has a specific amount of gas associated with it: <strong>gasLimit</strong>. This is the amount of gas which is implicitly purchased from the sender’s account balance. The purchase happens at the according <strong>gasPrice</strong>, also specified in the transaction. The transaction is considered invalid if the account balance cannot support such a purchase. It is named <strong>gasLimit</strong> since any unused gas at the end of the transaction is refunded (at the same rate of purchase) to the sender’s account. Gas does not exist outside of the execution of a transaction. Thus for accounts with trusted code associated, a relatively high gas limit may be set and left alone.</p>
<p>In general, Ether used to purchase gas that is not refunded is delivered to the <em>beneficiary</em> address, the address of an account typically under the control of the miner. Transactors are free to specify any <strong>gasPrice</strong> that they wish, however miners are free to ignore transactions as they choose. A higher gas price on a transaction will therefore cost the sender more in terms of Ether and deliver a greater value to the miner and thus will more likely be selected for inclusion by more miners. Miners, in general, will choose to advertise the minimum gas price for which they will execute transactions and transactors will be free to canvas these prices in determining what gas price to offer. Since there will be a (weighted) distribution of minimum acceptable gas prices, transactors will necessarily have a trade-off to make between lowering the gas price and maximising the chance that their transaction will be mined in a timely manner.</p>
<h1 id="ch:transactions">Transaction Execution</h1>
<p>The execution of a transaction is the most complex part of the Ethereum protocol: it defines the state transition function <a href="#Upsilon_state_transition"><span class="math inline"><em>Υ</em></span></a>. It is assumed that any transactions executed first pass the initial tests of intrinsic validity. These include:</p>
<ol>
<li><p>The transaction is well-formed RLP, with no additional trailing bytes;</p></li>
<li><p>the transaction signature is valid;</p></li>
<li><p>the <a href="#transaction_nonce">transaction nonce</a> is valid (equivalent to the <a href="#account_nonce">sender account’s current nonce</a>);</p></li>
<li><p>the sender account has no contract code deployed (see EIP-3607 by <span class="citation" data-cites="EIP-3607"></span>);</p></li>
<li><p>the gas limit is no smaller than the intrinsic gas, <span class="math inline"><em>g</em><sub>0</sub></span>, used by the transaction; and</p></li>
<li><p>the sender account balance contains at least the cost, <span class="math inline"><em>v</em><sub>0</sub></span>, required in up-front payment.</p></li>
</ol>
<p>Formally, we consider the function <a href="#Upsilon_state_transition"><span class="math inline"><em>Υ</em></span></a>, with <span class="math inline"><em>T</em></span> being a transaction and <span class="math inline"><strong>σ</strong></span> the state: <br /><span class="math display"><strong>σ</strong>′ = <em>Υ</em>(<strong>σ</strong>, <em>T</em>)</span><br /></p>
<p>Thus <span class="math inline"><strong>σ</strong>′</span> is the post-transactional state. We also define <a href="#tx_total_gas_used_Upsilon_pow_g"><span class="math inline"><em>Υ</em><sup><em>g</em></sup></span></a> to evaluate to the amount of gas used in the execution of a transaction, <a href="#tx_logs_Upsilon_pow_l"><span class="math inline"><em>Υ</em><sup><strong>l</strong></sup></span></a> to evaluate to the transaction’s accrued log items and <a href="#tx_status_Upsilon_pow_z"><span class="math inline"><em>Υ</em><sup><em>z</em></sup></span></a> to evaluate to the status code resulting from the transaction. These will be formally defined later.</p>
<h2 id="ch:substate">Substate</h2>
<p>Throughout transaction execution, we accrue certain information that is acted upon immediately following the transaction. We call this the <em>accrued transaction substate</em>, or <em>accrued substate</em> for short, and represent it as <span class="math inline"><em>A</em></span>, which is a tuple: <br /><span class="math display"><em>A</em> ≡ (<em>A</em><sub><strong>s</strong></sub>, <em>A</em><sub><strong>l</strong></sub>, <em>A</em><sub><strong>t</strong></sub>, <em>A</em><sub><em>r</em></sub>, <em>A</em><sub><strong>a</strong></sub>, <em>A</em><sub><strong>K</strong></sub>)</span><br /></p>
<div id="self_destruct_set_wordy_defn_A__s">

</div>
<p>The tuple contents include <span class="math inline"><em>A</em><sub><strong>s</strong></sub></span>, the self-destruct set: a set of accounts that will be discarded following the transaction’s completion. <span id="tx_log_series_wordy_defn_A__l"></span> <span class="math inline"><em>A</em><sub><strong>l</strong></sub></span> is the log series: this is a series of archived and indexable ‘checkpoints’ in VM code execution that allow for contract-calls to be easily tracked by onlookers external to the Ethereum world (such as decentralised application front-ends). <span id="tx_touched_accounts_wordy_defn_A__t"></span> <span class="math inline"><em>A</em><sub><strong>t</strong></sub></span> is the set of touched accounts, of which the empty ones are deleted at the end of a transaction. <span id="refund_balance_defn_words_A__r"></span><span class="math inline"><em>A</em><sub><em>r</em></sub></span> is the refund balance, increased through using the <a href="#SSTORE">SSTORE</a> instruction in order to reset contract storage to zero from some non-zero value. Though not immediately refunded, it is allowed to partially offset the total execution costs. Finally, EIP-2929 by <span class="citation" data-cites="EIP-2929"></span> introduced <span id="accessed_addresses_defn_words_A__a"></span><span class="math inline"><em>A</em><sub><strong>a</strong></sub></span>, the set of accessed account addresses, and <span id="accessed_storage_keys_defn_words_A__k"></span><span class="math inline"><em>A</em><sub><strong>K</strong></sub></span>, the set of accessed storage keys (more accurately, each element of <span class="math inline"><em>A</em><sub><strong>K</strong></sub></span> is a tuple of a 20-byte account address and a 32-byte storage slot).</p>
<p>We define the empty accrued substate <span class="math inline"><em>A</em><sup>0</sup></span> to have no self-destructs, no logs, no touched accounts, zero refund balance, all precompiled contracts in the accessed addresses, and no accessed storage: <br /><span class="math display"><em>A</em><sup>0</sup> ≡ (⌀, (), ⌀, 0, <em>π</em>, ⌀)</span><br /> where <span class="math inline">$\hyperlink{precompiled_set}{\pi}$</span> is the set of all precompiled addresses.</p>
<h2 id="execution">Execution</h2>
<div id="intrinsic_gas_g_0">

</div>
<p>We define intrinsic gas <span class="math inline"><em>g</em><sub>0</sub></span>, the amount of gas this transaction requires to be paid prior to execution, as follows: <br /><span class="math display">$$\begin{aligned}
g_0 \equiv {} &amp; \sum_{i \in T_{\mathbf{i}}, T_{\mathbf{d}}} \begin{cases} \hyperlink{G__txdatazero}{G_{\mathrm{txdatazero}}} &amp; \text{if} \quad i = 0 \\ \hyperlink{G__txdatanonzero}{G_{\mathrm{txdatanonzero}}} &amp; \text{otherwise} \end{cases} \\
\nonumber {} &amp; + \begin{cases} \hyperlink{G__txcreate}{G_{\mathrm{txcreate}}} &amp; \text{if} \quad T_{\mathrm{t}} = \varnothing \\ 0 &amp; \text{otherwise} \end{cases} \\
\nonumber {} &amp; + \hyperlink{G__transaction}{G_{\mathrm{transaction}}} \\
\nonumber {} &amp; + \sum_{j = 0}^{\lVert T_{\mathbf{A}} \rVert - 1} \big( G_{\mathrm{accesslistaddress}} + \lVert T_{\mathbf{A}}[j]_{\mathbf{s}} \rVert G_{\mathrm{accessliststorage}} \big)\end{aligned}$$</span><br /> where <span class="math inline"><em>T</em><sub><strong>i</strong></sub>, <em>T</em><sub><strong>d</strong></sub></span> means the series of bytes of the transaction’s associated data and initialisation EVM-code, depending on whether the transaction is for contract-creation or message-call. <span class="math inline"><em>G</em><sub><em>t</em><em>x</em><em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em></sub></span> is added if the transaction is contract-creating, but not if a result of EVM-code. <span class="math inline">$\hyperlink{G__accesslistaddress}{G_{\mathrm{accesslistaddress}}}$</span> and <span class="math inline">$\hyperlink{G__accessliststorage}{G_{\mathrm{accessliststorage}}}$</span> are the costs of warming up account and storage access, respectively. <span class="math inline"><em>G</em></span> is fully defined in Appendix <a href="#app:fees" data-reference-type="ref" data-reference="app:fees">23</a>.</p>
<p>The up-front cost <span class="math inline"><em>v</em><sub>0</sub></span> is calculated as: <br /><span class="math display">$$v_0 \equiv \hyperlink{tx_gas_limit_T__g}{T_{\mathrm{g}}} \hyperlink{tx_gas_price_T__p}{T_{\mathrm{p}}} + \hyperlink{tx_value_T__v}{T_{\mathrm{v}}}$$</span><br /></p>
<p>The validity is determined as: <br /><span class="math display">$$\begin{array}[t]{rcl}
S(T) &amp; \neq &amp; \varnothing \quad \wedge \\
\boldsymbol{\sigma}[S(T)]_{\mathrm{c}} &amp; = &amp; \texttt{KEC}\big( () \big) \quad \wedge \\
\Hy@raisedlink{\hypertarget{transaction_nonce}{}}{}T_{\mathrm{n}} &amp; = &amp; \boldsymbol{\sigma}[S(T)]_{\mathrm{n}} \quad \wedge \\
g_0 &amp; \leqslant &amp; T_{\mathrm{g}} \quad \wedge \\
v_0 &amp; \leqslant &amp; \boldsymbol{\sigma}[S(T)]_{\mathrm{b}} \quad \wedge \\
T_{\mathrm{g}} &amp; \leqslant &amp; {B_{\mathrm{H}}}_{\mathrm{l}} - \hyperlink{ell}{\ell}(B_{\mathbf{R}})_{\mathrm{u}}
\end{array}$$</span><br /> Note the final condition; the sum of the transaction’s gas limit, <span class="math inline"><em>T</em><sub><em>g</em></sub></span>, and the gas utilised in this block prior, given by <span class="math inline">$\hyperlink{ell}{\ell}(B_{\mathbf{R}})_{\mathrm{u}}$</span>, must be no greater than the block’s <strong>gasLimit</strong>, <span class="math inline"><em>B</em><sub><em>H</em></sub><sub><em>l</em></sub></span>. Also, with a slight abuse of notation, we assume that <span class="math inline"><strong>σ</strong>[<em>S</em>(<em>T</em>)]<sub><em>c</em></sub> = <code>KEC</code>(())</span>, <span class="math inline"><strong>σ</strong>[<em>S</em>(<em>T</em>)]<sub><em>n</em></sub> = 0</span>, and <span class="math inline"><strong>σ</strong>[<em>S</em>(<em>T</em>)]<sub><em>b</em></sub> = 0</span> if <span class="math inline"><strong>σ</strong>[<em>S</em>(<em>T</em>)] = ⌀</span>.</p>
<p>The execution of a valid transaction begins with an irrevocable change made to the state: the <a href="#account_nonce">nonce of the account of the sender</a>, <span class="math inline"><em>S</em>(<em>T</em>)</span>, is incremented by one and the balance is reduced by part of the up-front cost, <span class="math inline"><em>T</em><sub><em>g</em></sub><em>T</em><sub><em>p</em></sub></span>. The gas available for the proceeding computation, <span class="math inline"><em>g</em></span>, is defined as <span class="math inline"><em>T</em><sub><em>g</em></sub> − <em>g</em><sub>0</sub></span>. The computation, whether contract creation or a message call, results in an eventual state (which may legally be equivalent to the current state), the change to which is deterministic and never invalid: there can be no invalid transactions from this point.</p>
<p>We define the checkpoint state <span class="math inline"><strong>σ</strong><sub>0</sub></span>: <br /><span class="math display">$$\begin{aligned}
\Hy@raisedlink{\hypertarget{sigma_0}{}}{}\boldsymbol{\sigma}_0 &amp; \equiv &amp; \boldsymbol{\sigma} \quad \text{except:} \\
\boldsymbol{\sigma}_0[S(T)]_{\mathrm{b}} &amp; \equiv &amp; \boldsymbol{\sigma}[S(T)]_{\mathrm{b}} - T_{\mathrm{g}} T_{\mathrm{p}} \\
\boldsymbol{\sigma}_0[S(T)]_{\mathrm{n}} &amp; \equiv &amp; \boldsymbol{\sigma}[S(T)]_{\mathrm{n}} + 1\end{aligned}$$</span><br /></p>
<p>Evaluating <span class="math inline"><strong>σ</strong><sub><em>P</em></sub></span> from <span class="math inline"><strong>σ</strong><sub>0</sub></span> depends on the transaction type; either contract creation or message call; we define the tuple of post-execution provisional state <span class="math inline"><strong>σ</strong><sub><em>P</em></sub></span>, remaining gas <span class="math inline"><em>g</em>′</span>, accrued substate <span class="math inline"><em>A</em></span> and status code <span class="math inline"><em>z</em></span>: <br /><span class="math display">$$(\boldsymbol{\sigma}_{\mathrm{P}}, g', A, z) \equiv \begin{cases}
\hyperlink{lambda}{\Lambda}_{4}(\boldsymbol{\sigma}_0, A^*, S(T), S(T), g, &amp;\\ \quad\; T_{\mathrm{p}}, T_{\mathrm{v}}, T_{\mathbf{i}}, 0, \varnothing, \top) &amp; \text{if} \quad T_{\mathrm{t}} = \varnothing \\
\hyperlink{theta}{\Theta}_{4}(\boldsymbol{\sigma}_0, A^*, S(T), S(T), T_{\mathrm{t}}, &amp;\\ \quad\; T_{\mathrm{t}}, g, T_{\mathrm{p}}, T_{\mathrm{v}}, T_{\mathrm{v}}, T_{\mathbf{d}}, 0, \top) &amp; \text{otherwise}
\end{cases}$$</span><br /> where <br /><span class="math display">$$\begin{aligned}
A^* &amp; \equiv A^0 \quad \text{except} \\
A^*_{\mathbf{a}} &amp; \equiv A^0_{\mathbf{a}} \cup \{S(T)\} \cup_{E \in T_{\mathbf{A}}} \{ \hyperlink{access_list_entry}{E}_{\mathrm{a}} \} \\
A^*_{\mathbf{K}} &amp; \equiv \bigcup_{E \in T_{\mathbf{A}}} \big\{ \forall i &lt; \lVert E_{\mathbf{s}} \rVert, i \in \mathbb{N}: \; (E_{\mathrm{a}}, E_{\mathbf{s}}[i]) \big\}\end{aligned}$$</span><br /> and <span class="math inline"><em>g</em></span> is the amount of gas remaining after deducting the basic amount required to pay for the existence of the transaction: <br /><span class="math display"><em>g</em> ≡ <em>T</em><sub><em>g</em></sub> − <em>g</em><sub>0</sub></span><br /></p>
<p>Note we use <span class="math inline">$\hyperlink{theta}{\Theta}_{4}$</span> and <span class="math inline">$\hyperlink{lambda}{\Lambda}_{4}$</span> to denote the fact that only the first four components of the functions’ values are taken; the final represents the message-call’s output value (a byte array) and is unused in the context of transaction evaluation.</p>
<p>After the message call or contract creation is processed, the refund counter has to be incremented for the accounts that were self-destructed throughout its invocation. <br /><span class="math display"><em>A</em>′<sub><em>r</em></sub> ≡ <em>A</em><sub><em>r</em></sub> + ∑<sub><em>i</em> ∈ <em>A</em><sub><strong>s</strong></sub></sub><em>R</em><sub><em>s</em><em>e</em><em>l</em><em>f</em><em>d</em><em>e</em><em>s</em><em>t</em><em>r</em><em>u</em><em>c</em><em>t</em></sub></span><br /></p>
<p>Then the state is finalised by determining the amount to be refunded, <span class="math inline"><em>g</em><sup>*</sup></span> from the remaining gas, <span class="math inline"><em>g</em>′</span>, plus some allowance from the refund counter, to the sender at the original rate. <br /><span class="math display">$$g^* \equiv g' + \min \left\{ \Big\lfloor \dfrac{T_{\mathrm{g}} - g'}{2} \Big\rfloor, A'_{\mathrm{r}} \right\}$$</span><br /></p>
<p>The total refundable amount is the legitimately remaining gas <span class="math inline"><em>g</em>′</span>, added to <a href="#refund_balance_defn_words_A__r"><span class="math inline"><em>A</em><sub><em>r</em></sub></span></a>, with the latter component being capped up to a maximum of half (rounded down) of the total amount used <span class="math inline"><em>T</em><sub><em>g</em></sub> − <em>g</em>′</span>. Therefore, <span class="math inline"><em>g</em><sup>*</sup></span> is the total gas that remains after the transaction has been executed.</p>
<p>The Ether for the gas is given to the miner, whose address is specified as the beneficiary of the present block <span class="math inline"><em>B</em></span>. So we define the pre-final state <span class="math inline"><strong>σ</strong><sup>*</sup></span> in terms of the provisional state <span class="math inline"><strong>σ</strong><sub><em>P</em></sub></span>: <br /><span class="math display">$$\begin{aligned}
\boldsymbol{\sigma}^* &amp; \equiv &amp; \boldsymbol{\sigma}_{\mathrm{P}} \quad \text{except} \\
\boldsymbol{\sigma}^*[S(T)]_{\mathrm{b}} &amp; \equiv &amp; \boldsymbol{\sigma}_{\mathrm{P}}[S(T)]_{\mathrm{b}} + g^* T_{\mathrm{p}} \\
\boldsymbol{\sigma}^*[m]_{\mathrm{b}} &amp; \equiv &amp; \boldsymbol{\sigma}_{\mathrm{P}}[m]_{\mathrm{b}} + (T_{\mathrm{g}} - g^*) T_{\mathrm{p}} \\
m &amp; \equiv &amp; {B_{\mathrm{H}}}_{\mathrm{c}}\end{aligned}$$</span><br /></p>
<p>The final state, <span class="math inline"><strong>σ</strong>′</span>, is reached after deleting all accounts that either appear in the self-destruct set or are touched and empty: <br /><span class="math display">$$\begin{aligned}
\boldsymbol{\sigma}' &amp; \equiv &amp; \boldsymbol{\sigma}^* \quad \text{except} \\
\Hy@raisedlink{\hypertarget{self_destruct_list_A__s}{}}{}\forall i \in A_{\mathbf{s}}: \boldsymbol{\sigma}'[i] &amp; = &amp; \varnothing \\
\Hy@raisedlink{\hypertarget{touched_A__t}{}}{}\forall i \in A_{\mathbf{t}}: \boldsymbol{\sigma}'[i] &amp; = &amp; \varnothing \quad\text{if}\quad \mathtt{DEAD}(\boldsymbol{\sigma}^*\kern -2pt, i)\end{aligned}$$</span><br /></p>
<div id="tx_total_gas_used_Upsilon_pow_g">

</div>
<p><span id="tx_logs_Upsilon_pow_l"></span><span id="tx_status_Upsilon_pow_z"></span>And finally, we specify <span class="math inline"><em>Υ</em><sup><em>g</em></sup></span>, the total gas used in this transaction <span class="math inline"><em>Υ</em><sup><strong>l</strong></sup></span>, the logs created by this transaction and <span class="math inline"><em>Υ</em><sup><em>z</em></sup></span>, the status code of this transaction: <br /><span class="math display">$$\begin{aligned}
\Upsilon^{\mathrm{g}}(\boldsymbol{\sigma}, T) &amp; \equiv &amp; T_{\mathrm{g}} - g^* \\
\Upsilon^{\mathbf{l}}(\boldsymbol{\sigma}, T) &amp; \equiv &amp; \hyperlink{tx_log_series_wordy_defn_A__l}{A_{\mathbf{l}}} \\
\Upsilon^{\mathrm{z}}(\boldsymbol{\sigma}, T) &amp; \equiv &amp; z\end{aligned}$$</span><br /></p>
<p>These are used to help define the <a href="#Transaction_Receipt">transaction receipt</a> and are also used <a href="#sigma_n">later</a> for state and nonce validation.</p>
<h1 id="ch:create">Contract Creation</h1>
<div id="endow">

</div>
<p>There are a number of intrinsic parameters used when creating an account: sender (<span class="math inline"><em>s</em></span>), original transactor<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (<span class="math inline"><em>o</em></span>), available gas (<span class="math inline"><em>g</em></span>), gas price (<span class="math inline"><em>p</em></span>), endowment (<span class="math inline"><em>v</em></span>) together with an arbitrary length byte array, <span class="math inline"><strong>i</strong></span>, the initialisation EVM code, the present depth of the message-call/contract-creation stack (<span class="math inline"><em>e</em></span>), the salt for new account’s address (<span class="math inline"><em>ζ</em></span>) and finally the permission to make modifications to the state (<span class="math inline"><em>w</em></span>). The salt might be missing (<span class="math inline"><em>ζ</em> = ⌀</span>); formally, <br /><span class="math display"><em>ζ</em> ∈ 𝔹<sub>32</sub> ∪ 𝔹<sub>0</sub></span><br /> If the creation was caused by <span><a href="#create2">CREATE2</a></span>, then <span class="math inline"><em>ζ</em> ≠ ⌀</span>.</p>
<p>We define the creation function formally as the function , which evaluates from these values, together with the state <span class="math inline"><strong>σ</strong></span> and the accrued substate <span class="math inline"><em>A</em></span>, to the tuple containing the new state, remaining gas, new accrued substate, status code and output <span class="math inline">(<strong>σ</strong>′, <em>g</em>′, <em>A</em>′, <em>z</em>, <strong>o</strong>)</span>: <br /><span class="math display">(<strong>σ</strong>′, <em>g</em>′, <em>A</em>′, <em>z</em>, <strong>o</strong>) ≡ <em>Λ</em>(<strong>σ</strong>, <em>A</em>, <em>s</em>, <em>o</em>, <em>g</em>, <em>p</em>, <em>v</em>, <strong>i</strong>, <em>e</em>, <em>ζ</em>, <em>w</em>)</span><br /></p>
<p>The address of the new account is defined as being the rightmost 160 bits of the Keccak-256 hash of the <a href="#rlp">RLP</a> encoding of the structure containing only the sender and the <a href="#account_nonce">account nonce</a>. For <span><a href="#create2">CREATE2</a></span> the rule is different and is described in EIP-1014 by <span class="citation" data-cites="EIP-1014"></span>. Combining the two cases, we define the resultant address for the new account <span class="math inline"><em>a</em></span>: <br /><span class="math display">$$\begin{aligned}
a &amp; \equiv \mathtt{ADDR}(s, \boldsymbol{\sigma}[s]_{\mathrm{n}} - 1, \zeta, \mathbf{i}) \\
\label{eq:new-address} \mathtt{ADDR}(s, n, \zeta, \mathbf{i}) &amp; \equiv \mathcal{B}_{96..255}\Big(\mathtt{KEC}\big( L_{\mathrm{A}}(s, n, \zeta, \mathbf{i})\big) \Big) \\
L_{\mathrm{A}}(s, n, \zeta, \mathbf{i}) &amp; \equiv \begin{cases}
\mathtt{RLP}\big(\;(s, n)\;\big) &amp; \text{if}\ \zeta = \varnothing \\
(255) \cdot s \cdot \zeta \cdot \mathtt{KEC}(\mathbf{i}) &amp; \text{otherwise}
\end{cases}\end{aligned}$$</span><br /> where <span class="math inline">⋅</span> is the concatenation of byte arrays, <span class="math inline">ℬ<sub><em>a</em>..<em>b</em></sub>(<em>X</em>)</span> evaluates to a binary value containing the bits of indices in the range <span class="math inline">[<em>a</em>, <em>b</em>]</span> of the binary data <span class="math inline"><em>X</em></span>, and <span class="math inline"><strong>σ</strong>[<em>x</em>]</span> is the address state of <span class="math inline"><em>x</em></span>, or <span class="math inline">⌀</span> if none exists. Note we use one fewer than the sender’s nonce value; we assert that we have incremented the sender account’s nonce prior to this call, and so the value used is the sender’s nonce at the beginning of the responsible transaction or VM operation.</p>
<p>The address of the new account is added to the set of accessed accounts: <br /><span class="math display"><em>A</em><sup>*</sup> ≡ <em>A</em>  except  <em>A</em><sub><strong>a</strong></sub><sup>*</sup> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<em>a</em>}</span><br /></p>
<p>The account’s nonce is initially defined as one, the balance as the value passed, the storage as empty and the code hash as the Keccak 256-bit hash of the empty string; the sender’s balance is also reduced by the value passed. Thus the mutated state becomes <span class="math inline"><strong>σ</strong><sup>*</sup></span>: <br /><span class="math display"><strong>σ</strong><sup>*</sup> ≡ <strong>σ</strong>  except:</span><br /> <br /><span class="math display">$$\begin{aligned}
\boldsymbol{\sigma}^*[a] &amp;=&amp; \big( 1, v + v', \mathtt{\hyperlink{trie}{TRIE}}(\varnothing), \mathtt{KEC}\big(()\big) \big) \\
\boldsymbol{\sigma}^*[s] &amp;=&amp; \begin{cases}
\varnothing &amp; \text{if}\ \boldsymbol{\sigma}[s] = \varnothing \ \wedge\ v = 0 \\
\mathbf{a}^* &amp; \text{otherwise}
\end{cases} \\
\mathbf{a}^* &amp;\equiv&amp; (\boldsymbol{\sigma}[s]_{\mathrm{n}}, \boldsymbol{\sigma}[s]_{\mathrm{b}} - v, \boldsymbol{\sigma}[s]_{\mathbf{s}}, \boldsymbol{\sigma}[s]_{\mathrm{c}})\end{aligned}$$</span><br /></p>
<p>where <span class="math inline"><em>v</em>′</span> is the account’s pre-existing value, in the event it was previously in existence: <br /><span class="math display">$$v' \equiv \begin{cases}
0 &amp; \text{if} \quad \boldsymbol{\sigma}[a] = \varnothing\\
\boldsymbol{\sigma}[a]_{\mathrm{b}} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>Finally, the account is initialised through the execution of the initialising EVM code <span class="math inline"><strong>i</strong></span> according to the execution model (see section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>). Code execution can effect several events that are not internal to the execution state: the account’s storage can be altered, further accounts can be created and further message calls can be made. As such, the code execution function <span class="math inline">$\hyperlink{xi_def}{\Xi}$</span> evaluates to a tuple of the resultant state <span class="math inline"><strong>σ</strong><sup> * *</sup></span>, available gas remaining <span class="math inline"><em>g</em><sup> * *</sup></span>, the resultant accrued substate <span class="math inline"><em>A</em><sup> * *</sup></span> and the body code of the account <span class="math inline"><strong>o</strong></span>.</p>
<p><br /><span class="math display">$$(\boldsymbol{\sigma}^{**}, g^{**}, A^{**}, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}^*, g, A^*, I) \\$$</span><br /> where <span class="math inline"><em>I</em></span> contains the parameters of the <a href="#exec_env">execution environment</a>, that is:<br /><span class="math display">$$\begin{aligned}
I_{\mathrm{a}} &amp; \equiv &amp; a \\
I_{\mathrm{o}} &amp; \equiv &amp; o \\
I_{\mathrm{p}} &amp; \equiv &amp; p \\
I_{\mathbf{d}} &amp; \equiv &amp; () \\
I_{\mathrm{s}} &amp; \equiv &amp; s \\
\hyperlink{I__v}{I_{\mathrm{v}}} &amp; \equiv &amp; v \\
I_{\mathbf{b}} &amp; \equiv &amp; \mathbf{i} \\
I_{\mathrm{e}} &amp; \equiv &amp; e \\
I_{\mathrm{w}} &amp; \equiv &amp; w\end{aligned}$$</span><br /></p>
<p><span class="math inline"><em>I</em><sub><strong>d</strong></sub></span> evaluates to the empty tuple as there is no input data to this call. <span class="math inline"><em>I</em><sub><em>H</em></sub></span> has no special treatment and is determined from the blockchain.</p>
<p>Code execution depletes gas, and gas may not go below zero, thus execution may exit before the code has come to a natural halting state. In this (and several other) exceptional cases we say an out-of-gas (OOG) exception has occurred: The evaluated state is defined as being the empty set, <span class="math inline">⌀</span>, and the entire create operation should have no effect on the state, effectively leaving it as it was immediately prior to attempting the creation.</p>
<p>If the initialization code completes successfully, a final contract-creation cost is paid, the code-deposit cost, <span class="math inline"><em>c</em></span>, proportional to the size of the created contract’s code: <br /><span class="math display"><em>c</em> ≡ <em>G</em><sub><em>c</em><em>o</em><em>d</em><em>e</em><em>d</em><em>e</em><em>p</em><em>o</em><em>s</em><em>i</em><em>t</em></sub> × ∥<strong>o</strong>∥</span><br /></p>
<p>If there is not enough gas remaining to pay this, i.e.<span class="math inline"><em>g</em><sup> * *</sup> &lt; <em>c</em></span>, then we also declare an out-of-gas exception.</p>
<p>The gas remaining will be zero in any such exceptional condition, i.e. if the creation was conducted as the reception of a transaction, then this doesn’t affect payment of the intrinsic cost of contract creation; it is paid regardless. However, the value of the transaction is not transferred to the aborted contract’s address when we are out-of-gas, thus the contract’s code is not stored.</p>
<p>If such an exception does not occur, then the remaining gas is refunded to the originator and the now-altered state is allowed to persist. Thus formally, we may specify the resultant state, gas, accrued substate and status code as <span class="math inline">(<strong>σ</strong>′, <em>g</em>′, <em>A</em>′, <em>z</em>)</span> where:</p>
<p><br /><span class="math display">$$\begin{aligned}
\quad g' \equiv &amp; \begin{cases}
0 &amp; \text{if} \quad F \\
g^{**} - c &amp; \text{otherwise} \\
\end{cases} \\
\quad \boldsymbol{\sigma}' \equiv &amp; \begin{cases}
\boldsymbol{\sigma} &amp; \text{if} \quad F \ \lor\ \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} \quad \text{except:} &amp; \\
\quad\boldsymbol{\sigma}'[a] = \varnothing &amp; \text{if} \quad \mathtt{DEAD}(\boldsymbol{\sigma}^{**}, a) \\
\boldsymbol{\sigma}^{**} \quad \text{except:} &amp; \\
\quad\boldsymbol{\sigma}'[a]_{\mathrm{c}} = \texttt{KEC}(\mathbf{o}) &amp; \text{otherwise}
\end{cases} \\
\quad A' \equiv &amp; \begin{cases}
A^* &amp; \text{if} \quad F \ \lor\ \boldsymbol{\sigma}^{**} = \varnothing \\
A^{**} &amp; \text{otherwise} \\
\end{cases} \\
\quad z \equiv &amp; \begin{cases}
0 &amp; \text{if} \quad F \ \lor\ \boldsymbol{\sigma}^{**} = \varnothing \\
1 &amp; \text{otherwise}
\end{cases} \\
\nonumber \text{where} \\
F \equiv  &amp; \big( \boldsymbol{\sigma}[a] \neq \varnothing \ \wedge\ \big(\boldsymbol{\sigma}[a]_c \neq \texttt{\small KEC}\big(()\big) \vee \boldsymbol{\sigma}[a]_n \neq 0 \big) \big) \quad \vee \\
\nonumber &amp;(\boldsymbol{\sigma}^{**} = \varnothing \ \wedge\ \mathbf{o} = \varnothing) \quad \vee \\
\nonumber &amp;g^{**} &lt; c \quad \vee \\
\nonumber &amp;\lVert \mathbf{o} \rVert &gt; 24576\end{aligned}$$</span><br /> <span id="contract_creation_result"></span></p>
<p>The exception in the determination of <span class="math inline"><strong>σ</strong>′</span> dictates that <span class="math inline"><strong>o</strong></span>, the resultant byte sequence from the execution of the initialisation code, specifies the final body code for the newly-created account.</p>
<p>Note that intention is that the result is either a successfully created new contract with its endowment, or no new contract with no transfer of value. In addition, observe that if the execution of the initialising code <a href="#REVERT">reverts</a> (<span class="math inline"><strong>σ</strong><sup> * *</sup> = ⌀ ∧ <strong>o</strong> ≠ ⌀</span>), the resultant gas <span class="math inline"><em>g</em>′</span> is not depleted (provided there was no other exception), but no new account is created.</p>
<h2 id="subtleties">Subtleties</h2>
<p>Note that while the initialisation code is executing, the newly created address exists but with no intrinsic body code<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Thus any message call received by it during this time causes no code to be executed. If the initialisation execution ends with a <span>SELFDESTRUCT</span> instruction, the matter is moot since the account will be deleted before the transaction is completed. For a normal <span>STOP</span> code, or if the code returned is otherwise empty, then the state is left with a zombie account, and any remaining balance will be locked into the account forever.</p>
<h1 id="ch:call">Message Call</h1>
<p>In the case of executing a message call, several parameters are required: sender (<span class="math inline"><em>s</em></span>), transaction originator (<span class="math inline"><em>o</em></span>), recipient (<span class="math inline"><em>r</em></span>), the account whose code is to be executed (<span class="math inline"><em>c</em></span>, usually the same as recipient), available gas (<span class="math inline"><em>g</em></span>), value (<span class="math inline"><em>v</em></span>) and gas price (<span class="math inline"><em>p</em></span>) together with an arbitrary length byte array, <span class="math inline"><strong>d</strong></span>, the input data of the call, the present depth of the message-call/contract-creation stack (<span class="math inline"><em>e</em></span>) and finally the permission to make modifications to the state (<span class="math inline"><em>w</em></span>).</p>
<p>Aside from evaluating to a new state and accrued transaction substate, message calls also have an extra component—the output data denoted by the byte array <span class="math inline"><strong>o</strong></span>. This is ignored when executing transactions, however message calls can be initiated due to VM-code execution and in this case this information is used. <br /><span class="math display">$$(\boldsymbol{\sigma}', g', A', z, \mathbf{o}) \equiv \Hy@raisedlink{\hypertarget{theta}{}}{\Theta}(\boldsymbol{\sigma}, A, s, o, r, c, g, p, v, \tilde{v}, \mathbf{d}, e, w)$$</span><br /> Note that we need to differentiate between the value that is to be transferred, <span class="math inline"><em>v</em></span>, from the value apparent in the execution context, <span class="math inline"><em>ṽ</em></span>, for the <span>DELEGATECALL</span> instruction.</p>
<p>We define <span class="math inline"><strong>σ</strong><sub>1</sub></span>, the first transitional state as the original state but with the value transferred from sender to recipient: <br /><span class="math display"><strong>σ</strong><sub>1</sub>[<em>r</em>]<sub><em>b</em></sub> ≡ <strong>σ</strong>[<em>r</em>]<sub><em>b</em></sub> + <em>v</em>  ∧  <strong>σ</strong><sub>1</sub>[<em>s</em>]<sub><em>b</em></sub> ≡ <strong>σ</strong>[<em>s</em>]<sub><em>b</em></sub> − <em>v</em></span><br /> unless <span class="math inline"><em>s</em> = <em>r</em></span>.</p>
<p>Throughout the present work, it is assumed that if <span class="math inline"><strong>σ</strong><sub>1</sub>[<em>r</em>]</span> was originally undefined, it will be created as an account with no code or state and zero balance and nonce. Thus the previous equation should be taken to mean: <br /><span class="math display">$$\boldsymbol{\sigma}_1 \equiv \boldsymbol{\sigma}_1' \quad \text{except:} \\$$</span><br /> <br /><span class="math display">$$\boldsymbol{\sigma}_1[s] \equiv \begin{cases}
\varnothing &amp; \text{if}\ \boldsymbol{\sigma}_1'[s] = \varnothing \ \wedge\ v = 0 \\
\mathbf{a}_1 &amp;\text{otherwise}
\end{cases}$$</span><br /> <br /><span class="math display"><strong>a</strong><sub>1</sub> ≡ (<strong>σ</strong><sub>1</sub>′[<em>s</em>]<sub><em>n</em></sub>,<strong>σ</strong><sub>1</sub>′[<em>s</em>]<sub><em>b</em></sub>−<em>v</em>,<strong>σ</strong><sub>1</sub>′[<em>s</em>]<sub><strong>s</strong></sub>,<strong>σ</strong><sub>1</sub>′[<em>s</em>]<sub><em>c</em></sub>)</span><br /> <br /><span class="math display">$$\text{and}\quad \boldsymbol{\sigma}_1' \equiv \boldsymbol{\sigma} \quad \text{except:} \\$$</span><br /> <br /><span class="math display">$$\begin{cases}
\boldsymbol{\sigma}_1'[r] \equiv (0, v, \mathtt{TRIE}(\varnothing), \mathtt{KEC}(())) &amp; \text{if} \quad \boldsymbol{\sigma}[r] = \varnothing \wedge v \neq 0 \\
\boldsymbol{\sigma}_1'[r] \equiv \varnothing &amp; \text{if}\quad \boldsymbol{\sigma}[r] = \varnothing \wedge v = 0 \\
\boldsymbol{\sigma}_1'[r] \equiv \mathbf{a}_1' &amp; \text{otherwise}
\end{cases}$$</span><br /> <br /><span class="math display"><strong>a</strong><sub>1</sub>′ ≡ (<strong>σ</strong>[<em>r</em>]<sub><em>n</em></sub>, <strong>σ</strong>[<em>r</em>]<sub><em>b</em></sub> + <em>v</em>, <strong>σ</strong>[<em>r</em>]<sub><strong>s</strong></sub>, <strong>σ</strong>[<em>r</em>]<sub><em>c</em></sub>)</span><br /></p>
<p>The account’s associated code (identified as the fragment whose Keccak-256 hash is <span class="math inline"><strong>σ</strong>[<em>c</em>]<sub><em>c</em></sub></span>) is executed according to the execution model (see section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>). Just as with contract creation, if the execution halts in an exceptional fashion (i.e. due to an exhausted gas supply, stack underflow, invalid jump destination or invalid instruction), then no gas is refunded to the caller and the state is reverted to the point immediately prior to balance transfer (i.e. <span class="math inline"><strong>σ</strong></span>).</p>
<p><br /><span class="math display">$$\begin{aligned}
\boldsymbol{\sigma}' &amp; \equiv &amp; \begin{cases}
\boldsymbol{\sigma} &amp; \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} &amp; \text{otherwise}
\end{cases} \\
g' &amp; \equiv &amp; \begin{cases}
0 &amp; \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \ \wedge \\
&amp;\quad \mathbf{o} = \varnothing \\
g^{**} &amp; \text{otherwise}
\end{cases} \\
A' &amp; \equiv &amp; \begin{cases}
A &amp; \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
A^{**} &amp; \text{otherwise}
\end{cases} \\
z &amp; \equiv &amp; \begin{cases}
0 &amp; \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
1 &amp; \text{otherwise}
\end{cases} \\
\hypertarget{code_execution_result}{}
(\boldsymbol{\sigma}^{**}, g^{**}, A^{**}, \mathbf{o}) &amp; \equiv &amp; \Xi\\
I_{\mathrm{a}} &amp; \equiv &amp; r \\
I_{\mathrm{o}} &amp; \equiv &amp; o \\
I_{\mathrm{p}} &amp; \equiv &amp; p \\
I_{\mathbf{d}} &amp; \equiv &amp; \mathbf{d} \\
I_{\mathrm{s}} &amp; \equiv &amp; s \\
I_{\mathrm{v}} &amp; \equiv &amp; \tilde{v} \\
I_{\mathrm{e}} &amp; \equiv &amp; e \\
I_{\mathrm{w}} &amp; \equiv &amp; w\end{aligned}$$</span><br /> where <br /><span class="math display">$$\Xi \equiv \begin{cases}
\Xi_{\mathtt{ECREC}}    (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 1 \\
\Xi_{\mathtt{SHA256}}   (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 2 \\
\Xi_{\mathtt{RIP160}}   (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 3 \\
\Xi_{\mathtt{ID}}       (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 4 \\
\Xi_{\mathtt{EXPMOD}}   (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 5 \\
\Xi_{\mathtt{BN\_ADD}}  (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 6 \\
\Xi_{\mathtt{BN\_MUL}}  (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 7 \\
\Xi_{\mathtt{SNARKV}}   (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 8 \\
\Xi_{\mathtt{BLAKE2\_F}}(\boldsymbol{\sigma}_1, g, A, I) &amp; \text{if} \quad c = 9 \\
\Xi                     (\boldsymbol{\sigma}_1, g, A, I) &amp; \text{otherwise} \end{cases}$$</span><br /> and <br /><span class="math display"><code>K</code><code>E</code><code>C</code>(<em>I</em><sub><strong>b</strong></sub>) = <strong>σ</strong>[<em>c</em>]<sub><em>c</em></sub></span><br /> It is assumed that the client will have stored the pair <span class="math inline">(<code>K</code><code>E</code><code>C</code>(<em>I</em><sub><strong>b</strong></sub>), <em>I</em><sub><strong>b</strong></sub>)</span> at some point prior in order to make the determination of <span class="math inline"><em>I</em><sub><strong>b</strong></sub></span> feasible.</p>
<p>As can be seen, there are nine exceptions to the usage of the general execution framework <span class="math inline"><em>Ξ</em></span> for evaluation of the message call: these are so-called ‘precompiled’ contracts, meant as a preliminary piece of architecture that may later become <em>native extensions</em>. The contracts in addresses 1 to 9 execute the elliptic curve public key recovery function, the SHA2 256-bit hash scheme, the RIPEMD 160-bit hash scheme, the identity function, arbitrary precision modular exponentiation, elliptic curve addition, elliptic curve scalar multiplication, an elliptic curve pairing check, and the BLAKE2 compression function <span class="math inline"><code>F</code></span> respectively. Their full formal definition is in Appendix <a href="#app:precompiled" data-reference-type="ref" data-reference="app:precompiled">21</a>. <span id="precompiled_set"></span>We denote the set of the addresses of the precompiled contracts by <span class="math inline"><em>π</em></span>: <br /><span class="math display"><em>π</em> ≡ {1, 2, 3, 4, 5, 6, 7, 8, 9}</span><br /></p>
<h1 id="ch:model">Execution Model</h1>
<p>The execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data. This is specified through a formal model of a virtual state machine, known as the Ethereum Virtual Machine (EVM). It is a <em>quasi-</em>Turing-complete machine; the <em>quasi</em> qualification comes from the fact that the computation is intrinsically bounded through a parameter, <em>gas</em>, which limits the total amount of computation done.</p>
<h2 id="basics">Basics</h2>
<p>The EVM is a simple stack-based architecture. The word size of the machine (and thus size of stack items) is 256-bit. This was chosen to facilitate the Keccak-256 hash scheme and elliptic-curve computations. The memory model is a simple word-addressed byte array. The stack has a maximum size of <span class="math inline">1024</span>. The machine also has an independent storage model; this is similar in concept to the memory but rather than a byte array, it is a word-addressable word array. Unlike memory, which is volatile, storage is non volatile and is maintained as part of the system state. All locations in both storage and memory are well-defined initially as zero.</p>
<p>The machine does not follow the standard von Neumann architecture. Rather than storing program code in generally-accessible memory or storage, it is stored separately in a virtual ROM interactable only through a specialised instruction.</p>
<p>The machine can have exceptional execution for several reasons, including stack underflows and invalid instructions. Like the out-of-gas exception, they do not leave state changes intact. Rather, the machine halts immediately and reports the issue to the execution agent (either the transaction processor or, recursively, the spawning execution environment) which will deal with it separately.</p>
<h2 id="fees-overview">Fees Overview</h2>
<p>Fees (denominated in gas) are charged under three distinct circumstances, all three as prerequisite to the execution of an operation. The first and most common is the fee intrinsic to the computation of the operation (see Appendix <a href="#app:fees" data-reference-type="ref" data-reference="app:fees">23</a>). Secondly, gas may be deducted in order to form the payment for a subordinate message call or contract creation; this forms part of the payment for <span>CREATE</span>, <span>CREATE2</span>, <span>CALL</span> and <span>CALLCODE</span>. Finally, gas may be paid due to an increase in the usage of the memory.</p>
<p>Over an account’s execution, the total fee for memory-usage payable is proportional to smallest multiple of 32 bytes that are required such that all memory indices (whether for read or write) are included in the range. This is paid for on a just-in-time basis; as such, referencing an area of memory at least 32 bytes greater than any previously indexed memory will certainly result in an additional memory usage fee. Due to this fee it is highly unlikely addresses will ever go above 32-bit bounds. That said, implementations must be able to manage this eventuality.</p>
<p>Storage fees have a slightly nuanced behaviour—to incentivise minimisation of the use of storage (which corresponds directly to a larger state database on all nodes), the execution fee for an operation that clears an entry in the storage is not only waived, a qualified refund is given; in fact, this refund is effectively paid up-front since the initial usage of a storage location costs substantially more than normal usage.</p>
<p>See Appendix <a href="#app:vm" data-reference-type="ref" data-reference="app:vm">24</a> for a rigorous definition of the EVM gas cost.</p>
<h2 id="execution-environment">Execution Environment</h2>
<p>In addition to the system state <span class="math inline"><strong>σ</strong></span>, the remaining gas for computation <span class="math inline"><em>g</em></span>, and the accrued substate <span class="math inline"><em>A</em></span>, there are several pieces of important information used in the execution environment that the execution agent must provide; these are contained in the tuple <span class="math inline"><em>I</em></span>:</p>
<ul>
<li><p><span class="math inline"><em>I</em><sub><em>a</em></sub></span>, the address of the account which owns the code that is executing.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>o</em></sub></span>, the sender address of the transaction that originated this execution.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>p</em></sub></span>, the price of gas in the transaction that originated this execution.</p></li>
<li><p><span class="math inline"><em>I</em><sub><strong>d</strong></sub></span>, the byte array that is the input data to this execution; if the execution agent is a transaction, this would be the transaction data.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>s</em></sub></span>, the address of the account which caused the code to be executing; if the execution agent is a transaction, this would be the transaction sender.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>v</em></sub></span>, the value, in Wei, passed to this account as part of the same procedure as execution; if the execution agent is a transaction, this would be the transaction value.</p></li>
<li><p><span class="math inline"><em>I</em><sub><strong>b</strong></sub></span>, the byte array that is the machine code to be executed.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>H</em></sub></span>, the block header of the present block.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>e</em></sub></span>, the depth of the present message-call or contract-creation (i.e. the number of <span>CALL</span>s or <span>CREATE(2)</span>s being executed at present).</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>w</em></sub></span>, the permission to make modifications to the state.</p></li>
</ul>
<p>The execution model defines the function <span class="math inline"><em>Ξ</em></span>, which can compute the resultant state <span class="math inline"><strong>σ</strong>′</span>, the remaining gas <span class="math inline"><em>g</em>′</span>, the resultant accrued substate <span class="math inline"><em>A</em>′</span> and the resultant output, <span class="math inline"><strong>o</strong></span>, given these definitions. For the present context, we will define it as: <br /><span class="math display">(<strong>σ</strong>′, <em>g</em>′, <em>A</em>′, <strong>o</strong>) ≡ <em>Ξ</em>(<strong>σ</strong>, <em>g</em>, <em>A</em>, <em>I</em>)</span><br /> where we will remember that <span class="math inline"><em>A</em></span>, the accrued substate, is defined in section <a href="#ch:substate" data-reference-type="ref" data-reference="ch:substate">6.1</a>.</p>
<h2 id="execution-overview">Execution Overview</h2>
<p>We must now define the <span class="math inline"><em>Ξ</em></span> function. In most practical implementations this will be modelled as an iterative progression of the pair comprising the full system state, <span class="math inline"><strong>σ</strong></span> and the machine state, <span class="math inline"><strong>μ</strong></span>. Formally, we define it recursively with a function <span class="math inline"><em>X</em></span>. This uses an iterator function <span class="math inline"><em>O</em></span> (which defines the result of a single cycle of the state machine) together with functions <a href="#zhalt"><span class="math inline"><em>Z</em></span></a> which determines if the present state is an <a href="#zhalt">exceptional halting</a> state of the machine and <a href="#hhalt"><span class="math inline"><em>H</em></span></a>, specifying the output data of the instruction if and only if the present state is a <a href="#hhalt">normal halting</a> state of the machine.</p>
<div id="empty_sequence_vs_empty_set">

</div>
<p>The empty sequence, denoted <span class="math inline">()</span>, is not equal to the empty set, denoted <span class="math inline">⌀</span>; this is important when interpreting the output of <span class="math inline"><em>H</em></span>, which evaluates to <span class="math inline">⌀</span> when execution is to continue but a series (potentially empty) when execution should halt. <br /><span class="math display">$$\begin{aligned}
\Xi(\boldsymbol{\sigma}, g, A, I) &amp; \equiv &amp; (\boldsymbol{\sigma}'\!, \boldsymbol{\mu}'_{\mathrm{g}}, A', \mathbf{o}) \\
(\boldsymbol{\sigma}', \boldsymbol{\mu}'\!, A', ..., \mathbf{o}) &amp; \equiv &amp; X\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) \\
\boldsymbol{\mu}_{\mathrm{g}} &amp; \equiv &amp; g \\
\boldsymbol{\mu}_{\mathrm{pc}} &amp; \equiv &amp; 0 \\
\boldsymbol{\mu}_{\mathbf{m}} &amp; \equiv &amp; (0, 0, ...) \\
\boldsymbol{\mu}_{\mathrm{i}} &amp; \equiv &amp; 0 \\
\boldsymbol{\mu}_{\mathbf{s}} &amp; \equiv &amp; () \\
\boldsymbol{\mu}_{\mathbf{o}} &amp; \equiv &amp; ()\end{aligned}$$</span><br /> <br /><span class="math display">$$\label{eq:X-def}
X\big( (\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \big) \equiv \begin{cases}
\big(\varnothing, \boldsymbol{\mu}, A, I, \varnothing\big) &amp; \text{if} \quad Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \\
\big(\varnothing, \boldsymbol{\mu}', A, I, \mathbf{o}\big) &amp; \text{if} \quad w = \text{\small REVERT} \\
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \cdot \mathbf{o} &amp; \text{if} \quad \mathbf{o} \neq \varnothing \\
X\big(O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) &amp; \text{otherwise} \\
\end{cases}$$</span><br /></p>
<p>where <br /><span class="math display">$$\begin{aligned}
\mathbf{o} &amp; \equiv &amp; H(\boldsymbol{\mu}, I) \\
(a, b, c, d) \cdot e &amp; \equiv &amp; (a, b, c, d, e) \\
\boldsymbol{\mu}' &amp; \equiv &amp; \boldsymbol{\mu}\ \text{except:} \\
\boldsymbol{\mu}'_{\mathrm{g}} &amp; \equiv &amp; \boldsymbol{\mu}_{\mathrm{g}} - C(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\end{aligned}$$</span><br /></p>
<p>Note that, when we evaluate <span class="math inline"><em>Ξ</em></span>, we drop the fourth element <span class="math inline"><em>I</em>′</span> and extract the remaining gas <span class="math inline"><strong>μ</strong>′<sub><em>g</em></sub></span> from the resultant machine state <span class="math inline"><strong>μ</strong>′</span>.</p>
<p><span class="math inline"><em>X</em></span> is thus cycled (recursively here, but implementations are generally expected to use a simple iterative loop) until either <a href="#zhalt"><span class="math inline"><em>Z</em></span></a> becomes true indicating that the present state is exceptional and that the machine must be halted and any changes discarded or until <a href="#hhalt"><span class="math inline"><em>H</em></span></a> becomes a series (rather than the empty set) indicating that the machine has reached a controlled halt.</p>
<h3 id="machine-state">Machine State</h3>
<p>The machine state <span class="math inline"><strong>μ</strong></span> is defined as the tuple <span class="math inline">(<em>g</em>, <em>p</em><em>c</em>, <strong>m</strong>, <em>i</em>, <strong>s</strong>)</span> which are the gas available, the program counter <span class="math inline"><em>p</em><em>c</em> ∈ ℕ<sub>256</sub></span> , the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents <span class="math inline"><strong>μ</strong><sub><strong>m</strong></sub></span> are a series of zeroes of size <span class="math inline">2<sup>256</sup></span>.</p>
<p>For the ease of reading, the instruction mnemonics, written in small-caps (e.g.), should be interpreted as their numeric equivalents; the full table of instructions and their specifics is given in Appendix <a href="#app:vm" data-reference-type="ref" data-reference="app:vm">24</a>.</p>
<p>For the purposes of defining <span class="math inline"><em>Z</em></span>, <span class="math inline"><em>H</em></span> and <span class="math inline"><em>O</em></span>, we define <span class="math inline"><em>w</em></span> as the current operation to be executed: <br /><span class="math display">$$\label{eq:currentoperation}
w \equiv \begin{cases} I_{\mathbf{b}}[\boldsymbol{\mu}_{\mathrm{pc}}] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathrm{pc}} &lt; \lVert I_{\mathbf{b}} \rVert \\
\text{\hyperlink{stop}{\small STOP}} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>We also assume the fixed amounts of <span class="math inline"><strong>δ</strong></span> and <span class="math inline"><strong>α</strong></span>, specifying the stack items removed and added, both subscriptable on the instruction and an instruction cost function <span class="math inline"><em>C</em></span> evaluating to the full cost, in gas, of executing the given instruction.</p>
<h3 id="exceptional-halting">Exceptional Halting</h3>
<div id="Exceptional_Halting_function_Z">

</div>
<p>The exceptional halting function <span class="math inline"><em>Z</em></span> is defined as: <br /><span class="math display">$$Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \equiv
\begin{array}[t]{l}
\boldsymbol{\mu}_g &lt; C(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \quad \vee \\
\mathbf{\delta}_w = \varnothing \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert &lt; \mathbf{\delta}_w \quad \vee \\
( w = \text{\small JUMP} \; \wedge \; \boldsymbol{\mu}_\mathbf{s}[0] \notin D(I_\mathbf{b}) ) \quad \vee \\
( w = \text{\small JUMPI} \; \wedge \; \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \; \wedge \\
\quad \boldsymbol{\mu}_\mathbf{s}[0] \notin D(I_\mathbf{b}) ) \quad \vee \\
( w = \text{\small RETURNDATACOPY} \; \wedge \\ \quad \boldsymbol{\mu}_{\mathbf{s}}[1] + \boldsymbol{\mu}_{\mathbf{s}}[2] &gt; \lVert\boldsymbol{\mu}_{\mathbf{o}}\rVert) \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert - \mathbf{\delta}_w + \mathbf{\alpha}_w &gt; 1024 \quad \vee \\
( \neg I_{\mathrm{w}} \; \wedge \; W(w, \boldsymbol{\mu}) ) \quad \vee \\
( w = \text{\small SSTORE} \; \wedge \; \boldsymbol{\mu}_g \leqslant G_{\mathrm{callstipend}} )
\end{array}$$</span><br /> where <br /><span class="math display">$$W(w, \boldsymbol{\mu}) \equiv \\
\begin{array}[t]{l}
w \in \{\text{\small CREATE}, \text{\small CREATE2}, \text{\small SSTORE},\\ \text{\small SELFDESTRUCT}\} \ \vee \\
\text{\small LOG0} \le w \; \wedge \; w \le \text{\small LOG4} \quad \vee \\
w = \text{\small CALL} \; \wedge \; \boldsymbol{\mu}_{\mathbf{s}}[2] \neq 0
\end{array}$$</span><br /></p>
<p>This states that the execution is in an exceptional halting state if there is insufficient gas, if the instruction is invalid (and therefore its <span class="math inline"><em>δ</em></span> subscript is undefined), if there are insufficient stack items, if a <span>JUMP</span>/<span>JUMPI</span> destination is invalid, the new stack size would be larger than 1024 or state modification is attempted during a static call. The astute reader will realise that this implies that no instruction can, through its execution, cause an exceptional halt. Also, the execution is in an exceptional halting state if the gas left prior to executing an <a href="#SSTORE">SSTORE</a> instruction is less than or equal to the call stipend <span class="math inline">$\hyperlink{G__callstipend}{G_{\mathrm{callstipend}}}$</span> – see EIP-2200 by <span class="citation" data-cites="EIP-2200"></span> for more information.</p>
<h3 id="jump-destination-validity">Jump Destination Validity</h3>
<p>We previously used <span class="math inline"><em>D</em></span> as the function to determine the set of valid jump destinations given the code that is being run. We define this as any position in the code occupied by a <span>JUMPDEST</span> instruction.</p>
<p>All such positions must be on valid instruction boundaries, rather than sitting in the data portion of <span>PUSH</span> operations and must appear within the explicitly defined portion of the code (rather than in the implicitly defined <a href="#stop">STOP</a> operations that trail it).</p>
<p>Formally: <br /><span class="math display"><em>D</em>(<strong>c</strong>) ≡ <em>D</em><sub><em>J</em></sub>(<strong>c</strong>, 0)</span><br /></p>
<p>where: <br /><span class="math display">$$D_{\mathrm{J}}(\mathbf{c}, i) \equiv \begin{cases}
\{\} &amp; \text{if} \quad i \geqslant \lVert \mathbf{c} \rVert  \\
\{ i \} \cup D_{\mathrm{J}}(\mathbf{c}, N(i, \mathbf{c}[i])) &amp; \\
\quad\quad\text{if} \quad \mathbf{c}[i] = \text{\small JUMPDEST} \\
D_{\mathrm{J}}(\mathbf{c}, N(i, \mathbf{c}[i])) &amp; \text{otherwise} \\
\end{cases}$$</span><br /></p>
<p>where <span class="math inline"><em>N</em></span> is the next valid instruction position in the code, skipping the data of a <span>PUSH</span> instruction, if any: <br /><span class="math display">$$N(i, w) \equiv \begin{cases}
i + w - \text{\small PUSH1} + 2 &amp; \\
\quad\quad\text{if} \quad w \in [\text{\small PUSH1}, \text{\small PUSH32}] \\
i + 1 &amp; \text{otherwise} \end{cases}$$</span><br /></p>
<h3 id="normal-halting">Normal Halting</h3>
<div id="normal_halting_function_H">

</div>
<p>The normal halting function <span class="math inline"><em>H</em></span> is defined: <br /><span class="math display">$$H(\boldsymbol{\mu}, I) \equiv \begin{cases}
H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \ \text{if} \quad w \in \{\text{\small \hyperlink{RETURN}{RETURN}}, \text{\small REVERT}\} &amp;\\
() \quad\quad\ \text{if} \quad w \in \{ \text{\small \hyperlink{stop}{STOP}}, \text{\small \hyperlink{selfdestruct}{SELFDESTRUCT}} \} &amp;\\
\varnothing \quad\quad\ \text{otherwise}&amp;
\end{cases}$$</span><br /></p>
<p>The data-returning halt operations, <a href="#RETURN"></a> and , have a special function <span class="math inline">$H_{\text{\tiny RETURN}}$</span>. Note also the difference between the empty sequence and the empty set as discussed <a href="#empty_sequence_vs_empty_set">here</a>.</p>
<h2 id="the-execution-cycle">The Execution Cycle</h2>
<p>Stack items are added or removed from the left-most, lower-indexed portion of the series; all other items remain unchanged: <br /><span class="math display">$$\begin{aligned}
O\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) &amp; \equiv &amp; (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \\
\Delta &amp; \equiv &amp; \mathbf{\alpha}_{w} - \mathbf{\delta}_{w} \\
\lVert\boldsymbol{\mu}'_{\mathbf{s}}\rVert &amp; \equiv &amp; \lVert\boldsymbol{\mu}_{\mathbf{s}}\rVert + \Delta \\
\quad \forall x \in [\mathbf{\alpha}_{w}, \lVert\boldsymbol{\mu}'_{\mathbf{s}}\rVert): \boldsymbol{\mu}'_{\mathbf{s}}[x] &amp; \equiv &amp; \boldsymbol{\mu}_{\mathbf{s}}[x-\Delta]\end{aligned}$$</span><br /></p>
<p>The gas is reduced by the instruction’s gas cost and for most instructions, the program counter increments on each cycle, for the three exceptions, we assume a function <span class="math inline"><em>J</em></span>, subscripted by one of two instructions, which evaluates to the according value: <br /><span class="math display">$$\begin{aligned}
\quad \boldsymbol{\mu}'_{\mathrm{g}} &amp; \equiv &amp; \boldsymbol{\mu}_{\mathrm{g}} - C(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \label{eq:mu_pc}\\
\quad \boldsymbol{\mu}'_{\mathrm{pc}} &amp; \equiv &amp; \begin{cases}
\hyperlink{JUMP}{J_{\text{JUMP}}}(\boldsymbol{\mu}) &amp; \text{if} \quad w = \text{\small JUMP} \\
\hyperlink{JUMPI}{J_{\text{JUMPI}}}(\boldsymbol{\mu}) &amp; \text{if} \quad w = \text{\small JUMPI} \\
N(\boldsymbol{\mu}_{\mathrm{pc}}, w) &amp; \text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<p>In general, we assume the memory, accrued substate and system state do not change: <br /><span class="math display">$$\begin{aligned}
\boldsymbol{\mu}'_{\mathbf{m}} &amp; \equiv &amp; \boldsymbol{\mu}_{\mathbf{m}} \\
\boldsymbol{\mu}'_{\mathrm{i}} &amp; \equiv &amp; \boldsymbol{\mu}_{\mathrm{i}} \\
A' &amp; \equiv &amp; A \\
\boldsymbol{\sigma}' &amp; \equiv &amp; \boldsymbol{\sigma}\end{aligned}$$</span><br /></p>
<p>However, instructions do typically alter one or several components of these values. Altered components listed by instruction are noted in Appendix <a href="#app:vm" data-reference-type="ref" data-reference="app:vm">24</a>, alongside values for <span class="math inline"><em>α</em></span> and <span class="math inline"><em>δ</em></span> and a formal description of the gas requirements.</p>
<h1 id="ch:ghost">Blocktree to Blockchain</h1>
<p>The canonical blockchain is a path from root to leaf through the entire block tree. In order to have consensus over which path it is, conceptually we identify the path that has had the most computation done upon it, or, the <em>heaviest</em> path. Clearly one factor that helps determine the heaviest path is the block number of the leaf, equivalent to the number of blocks, not counting the unmined <a href="#Genesis_Block">genesis block</a>, in the path. The longer the path, the greater the total mining effort that must have been done in order to arrive at the leaf. This is akin to existing schemes, such as that employed in Bitcoin-derived protocols.</p>
<p>Since a block header includes the difficulty, the header alone is enough to validate the computation done. Any block contributes toward the total computation or <em>total difficulty</em> of a chain.</p>
<p>Thus we define the total difficulty of block <span class="math inline"><em>B</em></span> recursively as: <br /><span class="math display">$$\begin{aligned}
B_{\mathrm{t}} &amp; \equiv &amp; B'_{\mathrm{t}} + B_{\mathrm{d}} \\
B' &amp; \equiv &amp; P(B_{\mathrm{H}})\end{aligned}$$</span><br /></p>
<p>As such given a block <span class="math inline"><em>B</em></span>, <span class="math inline"><em>B</em><sub><em>t</em></sub></span> is its total difficulty, <span class="math inline"><em>B</em>′</span> is its parent block and <span class="math inline"><em>B</em><sub><em>d</em></sub></span> is its difficulty.</p>
<h1 id="ch:finalisation">Block Finalisation</h1>
<p>The process of finalising a block involves four stages:</p>
<ol>
<li><p>Validate (or, if mining, determine) ommers;</p></li>
<li><p>validate (or, if mining, determine) transactions;</p></li>
<li><p>apply rewards;</p></li>
<li><p>verify (or, if mining, compute a valid) state and <a href="#block_nonce">block nonce</a>.</p></li>
</ol>
<h2 id="ommer-validation">Ommer Validation</h2>
<p>The validation of <a href="#ommer_block_headers_B__U">ommer headers</a> means nothing more than verifying that each ommer header is both a valid header and satisfies the relation of <span class="math inline"><em>N</em></span>th-generation ommer to the present block where <span class="math inline"><em>N</em> ≤ 6</span>. The maximum of ommer headers is two. Formally: <br /><span class="math display">$$\lVert B_{\mathbf{U}} \rVert \leqslant 2 \bigwedge_{\mathbf{U} \in B_{\mathbf{U}}} \hyperlink{block_header_validity_function}{V({\mathbf{U}}})\; \wedge \; k({\mathbf{U}}, P(\mathbf{B}_{\mathbf{H}})_{\mathbf{H}}, 6)$$</span><br /></p>
<p>where <span class="math inline"><em>k</em></span> denotes the “is-kin” property: <br /><span class="math display">$$k(U, H, n) \equiv \begin{cases} \mathit{false} &amp; \text{if} \quad n = 0 \\
s(U, H) &amp;\\
\quad \vee \; k(U, P(H)_{\mathrm{H}}, n - 1) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>and <span class="math inline"><em>s</em></span> denotes the “is-sibling” property: <br /><span class="math display"><em>s</em>(<em>U</em>, <em>H</em>) ≡ (<em>P</em>(<em>H</em>) = <em>P</em>(<em>U</em>) ∧ <em>H</em> ≠ <em>U</em> ∧ <em>U</em> ∉ <em>B</em>(<em>H</em>)<sub><strong>U</strong></sub>)</span><br /> where <span class="math inline"><em>B</em>(<em>H</em>)</span> and <span class="math inline"><em>P</em>(<em>H</em>)</span> are the block and the parent block of the corresponding header <span class="math inline"><em>H</em></span> respectively.</p>
<h2 id="transaction-validation">Transaction Validation</h2>
<p>The given <strong>gasUsed</strong> must correspond faithfully to the transactions listed: <a href="#H__g"><span class="math inline"><em>B</em><sub><em>H</em></sub><sub><em>g</em></sub></span></a>, the total gas used in the block, must be equal to the accumulated gas used according to the final transaction: <br /><span class="math display">$$\hyperlink{H__g}{B_{\mathrm{H}}}_{\mathrm{g}} = \hyperlink{ell}{\ell}(\hyperlink{R__u}{\mathbf{R})_{\mathrm{u}}}$$</span><br /></p>
<h2 id="reward-application">Reward Application</h2>
<p>The application of rewards to a block involves raising the balance of the accounts of the beneficiary address of the block and each ommer by a certain amount. We raise the block’s beneficiary account by <a href="#R__block"><span class="math inline"><em>R</em><sub><em>b</em><em>l</em><em>o</em><em>c</em><em>k</em></sub></span></a>; for each ommer, we raise the block’s beneficiary by an additional <span class="math inline">$\frac{1}{32}$</span> of the block reward and the beneficiary of the ommer gets rewarded depending on the block number.<span id="Omega"></span> Formally we define the function <span class="math inline"><em>Ω</em></span>: <br /><span class="math display">$$\begin{aligned}
\\ \nonumber
\Omega(B, \boldsymbol{\sigma}) &amp; \equiv &amp; \boldsymbol{\sigma}': \boldsymbol{\sigma}' = \boldsymbol{\sigma} \quad \text{except:} \\
\qquad\boldsymbol{\sigma}'[{\mathbf{B}_{\mathrm{H}}}_{\mathrm{c}}]_{\mathrm{b}} &amp; = &amp; \boldsymbol{\sigma}[{\mathbf{B}_{\mathrm{H}}}_{\mathrm{c}}]_{\mathrm{b}} + \left(1 + \frac{\lVert \mathbf{B}_{\mathbf{U}}\rVert}{32}\right)R_{\mathrm{block}} \\
\\ \nonumber
\forall \mathbf{U} \in \mathbf{B}_{\mathbf{U}}: \\ \nonumber
\boldsymbol{\sigma}'[\mathbf{U}_{\mathrm{c}}] &amp; = &amp; \begin{cases}
\varnothing &amp;\text{if}\ \boldsymbol{\sigma}[\mathbf{U}_{\mathrm{c}}] = \varnothing\ \wedge\ R = 0 \\
\mathbf{a}' &amp;\text{otherwise}
\end{cases} \\
\mathbf{a}' &amp;\equiv&amp; (\boldsymbol{\sigma}[U_{\mathrm{c}}]_{\mathrm{n}}, \boldsymbol{\sigma}[U_{\mathrm{c}}]_{\mathrm{b}} + R, \boldsymbol{\sigma}[U_{\mathrm{c}}]_{\mathbf{s}}, \boldsymbol{\sigma}[U_{\mathrm{c}}]_{\mathrm{c}}) \\
R &amp; \equiv &amp; \left(1 + \frac{1}{8} (U_{\mathrm{i}} - {B_{\mathrm{H}}}_{\mathrm{i}})\right) R_{\mathrm{block}}\end{aligned}$$</span><br /></p>
<p>If there are collisions of the beneficiary addresses between ommers and the block (i.e. two ommers with the same beneficiary address or an ommer with the same beneficiary address as the present block), additions are applied cumulatively.</p>
<div id="block_reward_R__block">

</div>
<p>We define the block reward in Wei: <br /><span class="math display">$$R_{\mathrm{block}} = 10^{18} \times \begin{cases}
5 &amp;\text{if}\ H_{\mathrm{i}} &lt; F_{\mathrm{Byzantium}} \\
3 &amp;\text{if}\ F_{\mathrm{Byzantium}} \leqslant H_{\mathrm{i}} &lt; F_{\mathrm{Constantinople}} \\
2 &amp;\text{if}\ H_{\mathrm{i}} \geqslant F_{\mathrm{Constantinople}} \\
\end{cases} \\$$</span><br /></p>
<h2 id="sec:statenoncevalidation">State &amp; Nonce Validation</h2>
<div id="Gamma">

</div>
<p>We may now define the function, <span class="math inline"><em>Γ</em></span>, that maps a block <span class="math inline"><em>B</em></span> to its initiation state: <br /><span class="math display">$$\Gamma(B) \equiv \begin{cases}
\boldsymbol{\sigma}_0 &amp; \text{if} \quad P(B_{\mathrm{H}}) = \varnothing \\
\boldsymbol{\sigma}_{\mathrm{i}}: \mathtt{\hyperlink{trie}{TRIE}}(L_{\mathrm{S}}(\boldsymbol{\sigma}_{\mathrm{i}})) = {P(B_{\mathrm{H}})_{\mathrm{H}}}_{\mathrm{r}} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>Here, <span class="math inline"><code>T</code><code>R</code><code>I</code><code>E</code>(<em>L</em><sub><em>S</em></sub>(<strong>σ</strong><sub><em>i</em></sub>))</span> means the hash of the root node of a trie of state <span class="math inline"><strong>σ</strong><sub><em>i</em></sub></span>; it is assumed that implementations will store this in the state database, which is trivial and efficient since the trie is by nature an immutable data structure.</p>
<div id="Phi">

</div>
<p>And finally we define <span class="math inline"><em>Φ</em></span>, the block transition function, which maps an incomplete block <span class="math inline"><em>B</em></span> to a complete block <span class="math inline"><em>B</em>′</span>: <br /><span class="math display">$$\begin{aligned}
\Phi(B) &amp; \equiv &amp; B': \quad B' = B^* \quad \text{except:} \\
B'_{\mathrm{n}} &amp; = &amp; n: \quad x \leqslant \frac{2^{256}}{\hyperlink{H__d}{H_{\mathrm{d}}}} \\
B'_{\mathrm{m}} &amp; = &amp; m \quad \text{with } (x, m) = \mathtt{PoW}(B^*_{\hyperlink{H_cancel_n}{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}}, n, \mathbf{d}) \\
B^* &amp; \equiv &amp; B \quad \text{except:} \quad {\hyperlink{Transaction_Receipt}{B^*_{\mathrm{r}}}} = \hyperlink{r}{r}(\hyperlink{Pi}{\Pi}(\Gamma(B), B))\end{aligned}$$</span><br /></p>
<p>With <span class="math inline"><strong>d</strong></span> being a dataset as specified in Appendix <a href="#app:ethash" data-reference-type="ref" data-reference="app:ethash">26</a>.</p>
<p>As specified at the beginning of the present work, <a href="#Pi"><span class="math inline"><em>Π</em></span></a> is the state-transition function, which is defined in terms of <a href="#Omega"><span class="math inline"><em>Ω</em></span></a>, the block finalisation function and <a href="#Upsilon_state_transition"><span class="math inline"><em>Υ</em></span></a>, the transaction-evaluation function, both now well-defined.</p>
<p>As previously detailed, <span class="math inline"><strong>R</strong>[<em>n</em>]<sub><em>z</em></sub></span>, <span class="math inline"><strong>R</strong>[<em>n</em>]<sub><strong>l</strong></sub></span> and <span class="math inline"><strong>R</strong>[<em>n</em>]<sub><em>u</em></sub></span> are the <span class="math inline"><em>n</em></span>th corresponding status code, logs and cumulative gas used after each transaction (<span class="math inline"><strong>R</strong>[<em>n</em>]<sub><em>b</em></sub></span>, the fourth component in the tuple, has already been defined in terms of the logs). We also define the <span class="math inline"><em>n</em></span>th state <span class="math inline"><strong>σ</strong>[<em>n</em>]</span>, which is defined simply as the state resulting from applying the corresponding transaction to the state resulting from the previous transaction (or the block’s initial state in the case of the first such transaction): <br /><span class="math display">$$\Hy@raisedlink{\hypertarget{sigma_n}{}}{}
\boldsymbol{\sigma}[n] = \begin{cases} \hyperlink{Gamma}{\Gamma}(B) &amp; \text{if} \quad n &lt; 0 \\ \hyperlink{Upsilon}{\Upsilon}(\boldsymbol{\sigma}[n - 1], B_{\mathbf{T}}[n]) &amp; \text{otherwise} \end{cases}$$</span><br /></p>
<p>In the case of <span class="math inline"><em>B</em><sub><strong>R</strong></sub>[<em>n</em>]<sub><em>u</em></sub></span>, we take a similar approach defining each item as the gas used in evaluating the corresponding transaction summed with the previous item (or zero, if it is the first), giving us a running total: <br /><span class="math display">$$\mathbf{R}[n]_{\mathrm{u}} = \begin{cases} 0 &amp; \text{if} \quad n &lt; 0 \\
\begin{array}[b]{l}
\Upsilon^g(\boldsymbol{\sigma}[n - 1], B_{\mathbf{T}}[n])\\ \quad + \mathbf{R}[n-1]_{\mathrm{u}}
\end{array}
 &amp; \text{otherwise} \end{cases}$$</span><br /></p>
<p>For <span class="math inline"><strong>R</strong>[<em>n</em>]<sub><strong>l</strong></sub></span>, we utilise the <a href="#Upsilon_pow_l"><span class="math inline"><em>Υ</em><sup><strong>l</strong></sup></span></a> function that we conveniently defined in the transaction execution function. <br /><span class="math display"><strong>R</strong>[<em>n</em>]<sub><strong>l</strong></sub> = <em>Υ</em><sup><strong>l</strong></sup>(<strong>σ</strong>[<em>n</em> − 1], <em>B</em><sub><strong>T</strong></sub>[<em>n</em>])</span><br /></p>
<p>We define <a href="#Upsilon_pow_z"><span class="math inline"><strong>R</strong>[<em>n</em>]<sub><em>z</em></sub></span></a> in a similar manner. <br /><span class="math display"><strong>R</strong>[<em>n</em>]<sub><em>z</em></sub> = <em>Υ</em><sup><em>z</em></sup>(<strong>σ</strong>[<em>n</em> − 1], <em>B</em><sub><strong>T</strong></sub>[<em>n</em>])</span><br /></p>
<div id="Pi">

</div>
<p>Finally, we define <span class="math inline"><em>Π</em></span> as the new state given the block reward function <span class="math inline">$\hyperlink{Omega}{\Omega}$</span> applied to the final transaction’s resultant state, <span class="math inline">$\hyperlink{ell}{\ell}(\boldsymbol{\sigma})$</span>: <br /><span class="math display">$$\Pi(\boldsymbol{\sigma}, B) \equiv \hyperlink{Omega}{\Omega}(B, \ell(\boldsymbol{\sigma}))$$</span><br /></p>
<p>Thus the complete block-transition mechanism is defined, except for <span class="math inline"><code>P</code><code>o</code><code>W</code></span>, the proof-of-work function.</p>
<h2 id="ch:pow">Mining Proof-of-Work</h2>
<p>The mining proof-of-work (PoW) exists as a cryptographically secure nonce that proves beyond reasonable doubt that a particular amount of computation has been expended in the determination of some token value <span class="math inline"><em>n</em></span>. It is utilised to enforce the blockchain security by giving meaning and credence to the notion of difficulty (and, by extension, total difficulty). However, since mining new blocks comes with an attached reward, the proof-of-work not only functions as a method of securing confidence that the blockchain will remain canonical into the future, but also as a wealth distribution mechanism.</p>
<p>For both reasons, there are two important goals of the proof-of-work function; firstly, it should be as accessible as possible to as many people as possible. The requirement of, or reward from, specialised and uncommon hardware should be minimised. This makes the distribution model as open as possible, and, ideally, makes the act of mining a simple swap from electricity to Ether at roughly the same rate for anyone around the world.</p>
<p>Secondly, it should not be possible to make super-linear profits, and especially not so with a high initial barrier. Such a mechanism allows a well-funded adversary to gain a troublesome amount of the network’s total mining power and as such gives them a super-linear reward (thus skewing distribution in their favour) as well as reducing the network security.</p>
<p>One plague of the Bitcoin world is ASICs. These are specialised pieces of compute hardware that exist only to do a single task (<span class="citation" data-cites="ASICSmithMJS"></span>). In Bitcoin’s case the task is the SHA256 hash function (<span class="citation" data-cites="Courtois2014"></span>). While ASICs exist for a proof-of-work function, both goals are placed in jeopardy. Because of this, a proof-of-work function that is ASIC-resistant (i.e. difficult or economically inefficient to implement in specialised compute hardware) has been identified as the proverbial silver bullet.</p>
<p>Two directions exist for ASIC resistance; firstly make it sequential memory-hard, i.e. engineer the function such that the determination of the <a href="#block_nonce">nonce</a> requires a lot of memory and bandwidth such that the memory cannot be used in parallel to discover multiple nonces simultaneously. The second is to make the type of computation it would need to do general-purpose; the meaning of “specialised hardware” for a general-purpose task set is, naturally, general purpose hardware and as such commodity desktop computers are likely to be pretty close to “specialised hardware” for the task. For Ethereum 1.0 we have chosen the first path.</p>
<p>More formally, the proof-of-work function takes the form of <span class="math inline"><code>P</code><code>o</code><code>W</code></span>: <br /><span class="math display">$$m = \hyperlink{H__m}{H_{\mathrm{m}}} \quad \wedge \quad n \leqslant \frac{2^{256}}{\hyperlink{H__d}{H_{\mathrm{d}}}} \quad \text{with} \quad (m, n) = \mathtt{PoW}(\hyperlink{H_cancel_n}{H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}}, H_{\mathrm{n}}, \mathbf{d})$$</span><br /></p>
<p>Where <span class="math inline">$H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}$</span> is the new block’s header but <em>without</em> the nonce and mix-hash components; <span class="math inline"><em>H</em><sub><em>n</em></sub></span> is the nonce of the header; <span class="math inline"><strong>d</strong></span> is a large data set needed to compute the mixHash and <span class="math inline"><em>H</em><sub><em>d</em></sub></span> is the new block’s difficulty value (i.e. the block difficulty from section <a href="#ch:ghost" data-reference-type="ref" data-reference="ch:ghost">10</a>). <span class="math inline"><code>P</code><code>o</code><code>W</code></span> is the proof-of-work function which evaluates to an array with the first item being the mixHash and the second item being a pseudo-random number cryptographically dependent on <span class="math inline"><em>H</em></span> and <span class="math inline"><strong>d</strong></span>. The underlying algorithm is called Ethash and is described below.</p>
<h3 id="ethash">Ethash</h3>
<p>Ethash is the PoW algorithm for Ethereum 1.0. It is the latest version of Dagger-Hashimoto, introduced by <span class="citation" data-cites="dagger"></span> and <span class="citation" data-cites="hashimoto"></span>, although it can no longer appropriately be called that since many of the original features of both algorithms were drastically changed with R&amp;D from February 2015 until May 4 2015 (<span class="citation" data-cites="commitdateforEthash"></span>). The general route that the algorithm takes is as follows:</p>
<p>There exists a seed which can be computed for each block by scanning through the block headers up until that point. From the seed, one can compute a pseudorandom cache, <span class="math inline">$\hyperlink{J__cacheinit}{J_{\mathrm{cacheinit}}}$</span> bytes in initial size. Light clients store the cache. From the cache, we can generate a dataset, <span class="math inline">$\hyperlink{J__datasetinit}{J_{\mathrm{datasetinit}}}$</span> bytes in initial size, with the property that each item in the dataset depends on only a small number of items from the cache. Full clients and miners store the dataset. The dataset grows linearly with time.</p>
<p>Mining involves grabbing random slices of the dataset and hashing them together. Verification can be done with low memory by using the cache to regenerate the specific pieces of the dataset that you need, so you only need to store the cache. The large dataset is updated once every <span class="math inline">$\hyperlink{J__epoch}{J_{\mathrm{epoch}}}$</span> blocks, so the vast majority of a miner’s effort will be reading the dataset, not making changes to it. The mentioned parameters as well as the algorithm is explained in detail in Appendix <a href="#app:ethash" data-reference-type="ref" data-reference="app:ethash">26</a>.</p>
<h1 id="implementing-contracts">Implementing Contracts</h1>
<p>There are several patterns of contracts engineering that allow particular useful behaviours; two of these that we will briefly discuss are data feeds and random numbers.</p>
<h2 id="data-feeds">Data Feeds</h2>
<p>A data feed contract is one which provides a single service: it gives access to information from the external world within Ethereum. The accuracy and timeliness of this information is not guaranteed and it is the task of a secondary contract author—the contract that utilises the data feed—to determine how much trust can be placed in any single data feed.</p>
<p>The general pattern involves a single contract within Ethereum which, when given a message call, replies with some timely information concerning an external phenomenon. An example might be the local temperature of New York City. This would be implemented as a contract that returned that value of some known point in storage. Of course this point in storage must be maintained with the correct such temperature, and thus the second part of the pattern would be for an external server to run an Ethereum node, and immediately on discovery of a new block, creates a new valid transaction, sent to the contract, updating said value in storage. The contract’s code would accept such updates only from the identity contained on said server.</p>
<h2 id="random-numbers">Random Numbers</h2>
<p>Providing random numbers within a deterministic system is, naturally, an impossible task. However, we can approximate with pseudo-random numbers by utilising data which is generally unknowable at the time of transacting. Such data might include the block’s hash, the block’s timestamp and the block’s beneficiary address. In order to make it hard for malicious miners to control those values, one should use the <span><a href="#blockhash">BLOCKHASH</a></span> operation in order to use hashes of the previous 256 blocks as pseudo-random numbers. For a series of such numbers, a trivial solution would be to add some constant amount and hashing the result.</p>
<h1 id="ch:future">Future Directions</h1>
<p>The state database won’t be forced to maintain all past state <a href="#trie">trie</a> structures into the future. It should maintain an age for each node and eventually discard nodes that are neither recent enough nor checkpoints. Checkpoints, or a set of nodes in the database that allow a particular block’s state trie to be traversed, could be used to place a maximum limit on the amount of computation needed in order to retrieve any state throughout the blockchain.</p>
<p>Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download to act as a full, mining, node. A compressed archive of the trie structure at given points in time (perhaps one in every 10,000th block) could be maintained by the peer network, effectively recasting the <a href="#Genesis_Block">genesis block</a>. This would reduce the amount to be downloaded to a single archive plus a hard maximum limit of blocks.</p>
<p>Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven’t sent/received a transaction in some constant amount of blocks could be thrown out, reducing both Ether-leakage and the growth of the state database.</p>
<h2 id="scalability">Scalability</h2>
<p>Scalability remains an eternal concern. With a generalised state transition function, it becomes difficult to partition and parallelise transactions to apply the divide-and-conquer strategy. Unaddressed, the dynamic value-range of the system remains essentially fixed and as the average transaction value increases, the less valuable of them become ignored, being economically pointless to include in the main ledger. However, several strategies exist that may potentially be exploited to provide a considerably more scalable protocol.</p>
<p>Some form of hierarchical structure, achieved by either consolidating smaller lighter-weight chains into the main block or building the main block through the incremental combination and adhesion (through proof-of-work) of smaller transaction sets may allow parallelisation of transaction combination and block-building. Parallelism could also come from a prioritised set of parallel blockchains, consolidating each block and with duplicate or invalid transactions thrown out accordingly.</p>
<p>Finally, verifiable computation, if made generally available and efficient enough, may provide a route to allow the proof-of-work to be the verification of final state.</p>
<h1 id="ch:conclusion">Conclusion</h1>
<p>We have introduced, discussed and formally defined the protocol of Ethereum. Through this protocol the reader may implement a node on the Ethereum network and join others in a decentralised secure social operating system. Contracts may be authored in order to algorithmically specify and autonomously enforce rules of interaction.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>Many thanks to Aeron Buchanan for authoring the <em>Homestead</em> revisions, Christoph Jentzsch for authoring the Ethash algorithm and Yoichi Hirai for doing most of the EIP-150 changes. Important maintenance, useful corrections and suggestions were provided by a number of others from the Ethereum DEV organisation and Ethereum community at large including Gustav Simonsson, Paweł Bylica, Jutta Steiner, Nick Savers, Viktor Trón, Marko Simovic, Giacomo Tazzari and, of course, Vitalik Buterin.</p>
<h1 id="availability">Availability</h1>
<p>The source of this paper is maintained at <a href="https://github.com/ethereum/yellowpaper/">https://github.com/ethereum/yellowpaper/</a>. An auto-generated PDF is located at <a href="https://ethereum.github.io/yellowpaper/paper.pdf">https://ethereum.github.io/yellowpaper/paper.pdf</a>.</p>
<h1 id="ch:Terminology">Terminology</h1>
<dl>
<dt>External Actor</dt>
<dd><p>A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.</p>
</dd>
<dt>Address</dt>
<dd><p>A 160-bit code used for identifying Accounts.</p>
</dd>
<dt>Account</dt>
<dd><p>Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.</p>
</dd>
<dt>Transaction</dt>
<dd><p>A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.</p>
</dd>
<dt>Autonomous Object</dt>
<dd><p>A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated only as the Storage State of that account.</p>
</dd>
<dt>Storage State</dt>
<dd><p>The information particular to a given Account that is maintained between the times that the Account’s associated EVM Code runs.</p>
</dd>
<dt>Message</dt>
<dd><p>Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.</p>
</dd>
<dt>Message Call</dt>
<dd><p>The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.</p>
</dd>
<dt>Gas</dt>
<dd><p>The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.</p>
</dd>
<dt>Contract</dt>
<dd><p>Informal term used to mean both a piece of EVM Code that may be associated with an Account or an Autonomous Object.</p>
</dd>
<dt>Object</dt>
<dd><p>Synonym for Autonomous Object.</p>
</dd>
<dt>App</dt>
<dd><p>An end-user-visible application hosted in the Ethereum Browser.</p>
</dd>
<dt>Ethereum Browser</dt>
<dd><p>(aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum protocol.</p>
</dd>
<dt>Ethereum Virtual Machine</dt>
<dd><p>(aka EVM) The virtual machine that forms the key part of the execution model for an Account’s associated EVM Code.</p>
</dd>
<dt>Ethereum Runtime Environment</dt>
<dd><p>(aka ERE) The environment which is provided to an Autonomous Object executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for certain I/O instructions including CALL &amp; CREATE.</p>
</dd>
<dt>EVM Code</dt>
<dd><p>The bytecode that the EVM can natively execute. Used to formally specify the meaning and ramifications of a message to an Account.</p>
</dd>
<dt>EVM Assembly</dt>
<dd><p>The human-readable form of EVM-code.</p>
</dd>
<dt>LLL</dt>
<dd><p>The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general low-level language toolkit for trans-compiling to.</p>
</dd>
</dl>
<h1 id="app:rlp">Recursive Length Prefix</h1>
<div id="rlp">

</div>
<p>This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).</p>
<p>We define the set of possible structures <span class="math inline">𝕋</span>: <br /><span class="math display">$$\begin{aligned}
\mathbb{T} &amp; \equiv &amp; \mathbb{L} \uplus \mathbb{B} \\
\mathbb{L} &amp; \equiv &amp; \{ \mathbf{t}: \mathbf{t} = ( \mathbf{t}[0], \mathbf{t}[1], ... ) \; \wedge \; \forall n &lt; \lVert \mathbf{t} \rVert : \mathbf{t}[n] \in \mathbb{T} \} \\
\mathbb{B} &amp; \equiv &amp; \{ \mathbf{b}: \mathbf{b} = ( \mathbf{b}[0], \mathbf{b}[1], ... ) \; \wedge \; \forall n &lt; \lVert \mathbf{b} \rVert : \mathbf{b}[n] \in \mathbb{O} \}\end{aligned}$$</span><br /></p>
<p>Where <span class="math inline">𝕆</span> is the set of (8-bit) bytes. Thus <span class="math inline">𝔹</span> is the set of all sequences of bytes (otherwise known as byte arrays, and a leaf if imagined as a tree), <span class="math inline">𝕃</span> is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined as a tree) and <span class="math inline">𝕋</span> is the set of all byte arrays and such structural sequences. The disjoint union <span class="math inline">⊎</span> is needed only to distinguish the empty byte array <span class="math inline">() ∈ 𝔹</span> from the empty list <span class="math inline">() ∈ 𝕃</span>, which are encoded differently as defined below; as common, we will abuse notation and leave the disjoint union indices implicit, inferable from context.</p>
<p>We define the RLP function as <span class="math inline"><code>R</code><code>L</code><code>P</code></span> through two sub-functions, the first handling the instance when the value is a byte array, the second when it is a sequence of further values: <br /><span class="math display">$$\mathtt{RLP}(\mathbf{x}) \equiv \begin{cases} R_{\mathrm{b}}(\mathbf{x}) &amp; \text{if} \quad \mathbf{x} \in \mathbb{B} \\ R_{\mathrm{l}}(\mathbf{x}) &amp; \text{otherwise} \end{cases}$$</span><br /></p>
<div id="RLP_serialisation_of_a_byte_array_R__b_word_def">

</div>
<p>If the value to be serialised is a byte array, the RLP serialisation takes one of three forms:</p>
<ul>
<li><p>If the byte array contains solely a single byte and that single byte is less than 128, then the input is exactly equal to the output.</p></li>
<li><p>If the byte array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to the length of the byte array plus 128.</p></li>
<li><p>Otherwise, the output is equal to the input, provided that it contains fewer than <span class="math inline">2<sup>64</sup></span> bytes, prefixed by the minimal-length byte array which when interpreted as a big-endian integer is equal to the length of the input byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 183.</p></li>
</ul>
<p>Byte arrays containing <span class="math inline">2<sup>64</sup></span> or more bytes cannot be encoded. This restriction ensures that the first byte of the encoding of a byte array is always below 192, and thus it can be readily distinguished from the encodings of sequences in <span class="math inline">𝕃</span>.</p>
<div id="RLP_serialisation_of_a_byte_array_R__b_math_def">

</div>
<p>Formally, we define <span class="math inline"><em>R</em><sub><em>b</em></sub></span>: <br /><span class="math display">$$\begin{aligned}
R_{\mathrm{b}}(\mathbf{x}) &amp; \equiv &amp; \begin{cases}
\mathbf{x} &amp; \text{if} \quad \lVert \mathbf{x} \rVert = 1 \wedge \mathbf{x}[0] &lt; 128 \\
(128 + \lVert \mathbf{x} \rVert) \cdot \mathbf{x} &amp; \text{else if} \quad \lVert \mathbf{x} \rVert &lt; 56 \\
\big(183 + \big\lVert \mathtt{BE}(\lVert \mathbf{x} \rVert) \big\rVert \big) \cdot \mathtt{BE}(\lVert \mathbf{x} \rVert) \cdot \mathbf{x} &amp; \text{else if} \quad \lVert \mathbf{x} \rVert &lt; 2^{64} \\
\varnothing &amp; \text{otherwise}
\end{cases} \\
\label{eq:BE}
\mathtt{BE}(x) &amp; \equiv &amp; (b_0, b_1, ...): b_0 \neq 0 \wedge x = \sum_{n = 0}^{\lVert \mathbf{b} \rVert - 1} b_n \cdot 256^{\lVert \mathbf{b} \rVert - 1 - n} \\
(x_1, ..., x_n) \cdot (y_1, ..., y_m) &amp; = &amp; (x_1, ..., x_n, y_1, ..., y_m)\end{aligned}$$</span><br /></p>
<p>Thus <span class="math inline"><code>B</code><code>E</code></span> is the function that expands a non-negative integer value to a big-endian byte array of minimal length and the dot operator performs sequence concatenation.</p>
<div id="RLP_serialisation_of_a_sequence_of_other_items_R__l_word_def">

</div>
<p>If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:</p>
<ul>
<li><p>If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal to that concatenation prefixed by the byte equal to the length of this byte array plus 192.</p></li>
<li><p>Otherwise, the output is equal to the concatenated serialisations, provided that they contain fewer than <span class="math inline">2<sup>64</sup></span> bytes, prefixed by the minimal-length byte array which when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 247.</p></li>
</ul>
<p>Sequences whose concatenated serialized items contain <span class="math inline">2<sup>64</sup></span> or more bytes cannot be encoded. This restriction ensures that the first byte of the encoding does not exceed 255 (otherwise it would not be a byte).</p>
<div id="RLP_serialisation_of_a_sequence_of_other_items_R__l_math_def">

</div>
<p>Thus we finish by formally defining <span class="math inline"><em>R</em><sub><em>l</em></sub></span>: <br /><span class="math display">$$\begin{aligned}
R_{\mathrm{l}}(\mathbf{x}) &amp; \equiv &amp; \begin{cases}
(192 + \lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) &amp; \text{if} \quad s(\mathbf{x}) \neq \varnothing \wedge \lVert s(\mathbf{x}) \rVert &lt; 56 \\
\big(247 + \big\lVert \mathtt{BE}(\lVert s(\mathbf{x}) \rVert) \big\rVert \big) \cdot \mathtt{BE}(\lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) &amp; \text{else if} \quad s(\mathbf{x}) \neq \varnothing \wedge \lVert s(\mathbf{x}) \rVert &lt; 2^{64} \\
\varnothing &amp; \text{otherwise}
\end{cases} \\
s(\mathbf{x}) &amp; \equiv &amp; \begin{cases}
\mathtt{RLP}(\mathbf{x}[0]) \cdot \mathtt{RLP}(\mathbf{x}[1]) \cdot ... &amp; \text{if} \quad \forall i: \mathtt{RLP}(\mathbf{x}[i]) \neq \varnothing \\
\varnothing &amp; \text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<p>If RLP is used to encode a scalar, defined only as a non-negative integer (in <span class="math inline">ℕ</span>, or in <span class="math inline">ℕ<sub><em>x</em></sub></span> for any <span class="math inline"><em>x</em></span>), it must be encoded as the shortest byte array whose big-endian interpretation is the scalar. Thus the RLP of some non-negative integer <span class="math inline"><em>i</em></span> is defined as: <br /><span class="math display"><code>R</code><code>L</code><code>P</code>(<em>i</em> : <em>i</em> ∈ ℕ) ≡ <code>R</code><code>L</code><code>P</code>(<code>B</code><code>E</code>(<em>i</em>))</span><br /></p>
<p>When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data, dismissing it completely.</p>
<p>There is no specific canonical encoding format for signed or floating-point values.</p>
<h1 id="app:hexprefix">Hex-Prefix Encoding</h1>
<p>Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates between node types.</p>
<p>It is defined as the function <span class="math inline"><code>H</code><code>P</code></span> which maps from a sequence of nibbles (represented by the set <span class="math inline">𝕐</span>) together with a boolean value to a sequence of bytes (represented by the set <span class="math inline">𝔹</span>):</p>
<p><br /><span class="math display">$$\begin{aligned}
\mathtt{HP}(\mathbf{x}, t): \mathbf{x} \in \mathbb{Y} &amp; \equiv &amp; \begin{cases}
(16f(t), 16\mathbf{x}[0] + \mathbf{x}[1], 16\mathbf{x}[2] + \mathbf{x}[3], ...) &amp;
\text{if} \quad \lVert \mathbf{x} \rVert \; \text{is even} \\
(16(f(t) + 1) + \mathbf{x}[0], 16\mathbf{x}[1] + \mathbf{x}[2], 16\mathbf{x}[3] + \mathbf{x}[4], ...) &amp;
\text{otherwise}
\end{cases} \\
f(t) &amp; \equiv &amp; \begin{cases} 2 &amp; \text{if} \quad t \neq 0 \\ 0 &amp; \text{otherwise} \end{cases}\end{aligned}$$</span><br /></p>
<p>Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the second-lowest encoding the flag <span class="math inline"><em>t</em></span>. The low nibble of the first byte is zero in the case of an even number of nibbles and the first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining bytes.</p>
<h1 id="app:trie">Modified Merkle Patricia Tree</h1>
<div id="trie">

</div>
<p>The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms of the protocol specification, is to provide a single value that identifies a given set of key-value pairs, which may be either a 32-byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the structure of the trie in a manner that allows effective and efficient realisation of the protocol.</p>
<p>Formally, we assume the input value <span class="math inline">ℑ</span>, a set containing pairs of byte sequences with unique keys: <br /><span class="math display">ℑ = {(<strong>k</strong><sub>0</sub> ∈ 𝔹, <strong>v</strong><sub>0</sub> ∈ 𝔹), (<strong>k</strong><sub>1</sub> ∈ 𝔹, <strong>v</strong><sub>1</sub> ∈ 𝔹), ...}</span><br /></p>
<p>When considering such a sequence, we use the common numeric subscript notation to refer to a tuple’s key or value, thus: <br /><span class="math display">∀<em>I</em> ∈ ℑ : <em>I</em> ≡ (<em>I</em><sub>0</sub>, <em>I</em><sub>1</sub>)</span><br /></p>
<p>Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume big-endian. Thus: <br /><span class="math display">$$\begin{aligned}
y(\mathfrak{I}) &amp; = &amp; \{ (\mathbf{k}_0' \in \hyperlink{set_of_sequence_of_nibbles}{\mathbb{Y}}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1' \in \mathbb{Y}, \mathbf{v}_1 \in \mathbb{B}), ... \} \\
\forall n: \quad \forall i &lt; 2\lVert\mathbf{k}_{n}\rVert: \quad \mathbf{k}_{n}'[i] &amp; \equiv &amp;
\begin{cases}
\lfloor \mathbf{k}_{n}[i \div 2] \div 16 \rfloor &amp; \text{if} \; i \; \text{is even} \\
\mathbf{k}_{n}[\lfloor i \div 2 \rfloor] \bmod 16 &amp; \text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<p>We define the function <span class="math inline"><code>TRIE</code></span>, which evaluates to the root of the trie that represents this set when encoded in this structure: <br /><span class="math display"><code>TRIE</code>(ℑ) ≡ <code>KEC</code>(<code>RLP</code>(<em>c</em>(ℑ, 0)))</span><br /></p>
<p>We also assume a function <span class="math inline"><em>n</em></span>, the trie’s node cap function. When composing a node, we use RLP to encode the structure. As a means of reducing storage complexity, we store nodes whose composed RLP is fewer than 32 bytes directly; for those larger we assert prescience of the byte array whose Keccak-256 hash evaluates to our reference. Thus we define in terms of <span class="math inline"><em>c</em></span>, the node composition function: <br /><span class="math display">$$n(\mathfrak{I}, i) \equiv \begin{cases}
() \in \mathbb{B} &amp; \text{if} \quad \mathfrak{I} = \varnothing \\
c(\mathfrak{I}, i) &amp; \text{if} \quad \lVert \, \texttt{RLP} \big( c(\mathfrak{I}, i) \big) \rVert &lt; 32 \\
\texttt{KEC}\big(\texttt{RLP}( c(\mathfrak{I}, i)) \big) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree). Unlike a radix tree, in the case of multiple keys sharing the same prefix or in the case of a single key having a unique suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:</p>
<dl>
<dt>Leaf</dt>
<dd><p>A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be 1.</p>
</dd>
<dt>Extension</dt>
<dd><p>A two-item structure whose first item corresponds to a series of nibbles of size greater than one that are shared by at least two distinct keys past the accumulation of the keys of nibbles and the keys of branches as traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be 0.</p>
</dd>
<dt>Branch</dt>
<dd><p>A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and thus a key being ended at this point in its traversal.</p>
</dd>
</dl>
<p>A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We may formally define this structure with the structural composition function <span class="math inline"><em>c</em></span>: <br /><span class="math display">$$c(\mathfrak{I}, i) \equiv \begin{cases}
 \big(\texttt{HP}(I_0[i .. (\lVert I_0\rVert - 1)], 1), I_1 \big) &amp; \text{if} \quad \lVert \mathfrak{I} \rVert = 1 \quad \text{where} \; \exists I: I \in \mathfrak{I} \\
\big(\texttt{HP}(I_0[i .. (j - 1)], 0), n(\mathfrak{I}, j) \big) &amp; \text{if} \quad i \ne j \quad \text{where} \; j = \max \{ x : \exists \mathbf{l}: \lVert \mathbf{l} \rVert = x \wedge \forall I \in \mathfrak{I}: I_0[0 .. (x - 1)] = \mathbf{l} \} \\
(u(0), u(1), ..., u(15), v) &amp; \text{otherwise} \quad \text{where} \begin{array}[t]{rcl}
u(j) &amp; \equiv &amp; n(\{ I : I \in \mathfrak{I} \wedge I_0[i] = j \}, i + 1) \\
v &amp; = &amp; \begin{cases}
I_1 &amp; \text{if} \quad \exists I: I \in \mathfrak{I} \wedge \lVert I_0 \rVert = i \\
() \in \mathbb{B} &amp; \text{otherwise}
\end{cases}
\end{array}
\end{cases}$$</span><br /></p>
<h2 id="trie-database">Trie Database</h2>
<p>Thus no explicit assumptions are made concerning what data is stored and what is not, since that is an implementation-specific consideration; we simply define the identity function mapping the key-value set <span class="math inline">ℑ</span> to a 32-byte hash and assert that only a single such hash exists for any <span class="math inline">ℑ</span>, which though not strictly true is accurate within acceptable precision given the Keccak hash’s collision resistance. In reality, a sensible implementation will not fully recompute the trie root hash for each set.</p>
<p>A reasonable implementation will maintain a database of nodes determined from the computation of various tries or, more formally, it will memoise the function <span class="math inline"><em>c</em></span>. This strategy uses the nature of the trie to both easily recall the contents of any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship, Merkle-proofs may be constructed with an <span class="math inline"><em>O</em>(log <em>N</em>)</span> space requirement that can demonstrate a particular leaf must exist within a trie of a given root hash.</p>
<h1 id="app:precompiled">Precompiled Contracts</h1>
<p>For each precompiled contract, we make use of a template function, <span class="math inline"><em>Ξ</em><sub><code>P</code><code>R</code><code>E</code></sub></span>, which implements the out-of-gas checking. <br /><span class="math display">$$\label{eq:pre}
\Xi_{\mathtt{PRE}}(\boldsymbol{\sigma}, g, A, I) \equiv \begin{cases}
(\varnothing, 0, A, ()) &amp; \text{if} \quad g &lt; g_{\mathrm{r}} \\
(\boldsymbol\sigma, g - g_{\mathrm{r}}, A, \mathbf{o}) &amp; \text{otherwise}\end{cases}$$</span><br /></p>
<p>The precompiled contracts each use these definitions and provide specifications for the <span class="math inline"><strong>o</strong></span> (the output data) and <span class="math inline"><em>g</em><sub><em>r</em></sub></span>, the gas requirements.</p>
<p>We define <span class="math inline"><em>Ξ</em><sub><code>E</code><code>C</code><code>R</code><code>E</code><code>C</code></sub></span> as a precompiled contract for the elliptic curve digital signature algorithm (ECDSA) public key recovery function (ecrecover). See Appendix <a href="#app:signing" data-reference-type="ref" data-reference="app:signing">22</a> for the definition of the function <span class="math inline"><code>E</code><code>C</code><code>D</code><code>S</code><code>A</code><code>R</code><code>E</code><code>C</code><code>O</code><code>V</code><code>E</code><code>R</code></span> and the constant <span class="math inline"><code>s</code><code>e</code><code>c</code><code>p</code><code>256</code><code>k</code><code>1</code><code>n</code></span>. We also define <span class="math inline"><strong>d</strong></span> to be the input data, well-defined for an infinite length by appending zeroes as required. In the case of an invalid signature, we return no output.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{ECREC}} &amp;\equiv&amp; \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_{\mathrm{r}} &amp;=&amp; 3000\\
\lVert \mathbf{o} \rVert &amp;=&amp; \begin{cases} \label{eq:ecrec_precompile_validity}
  0 &amp; \text{if} \quad v \notin \{27, 28\} \,\vee\, r = 0 \,\vee\, r \ge \mathtt{secp256k1n} \,\vee\, s = 0 \,\vee\, s \ge \mathtt{secp256k1n} \\
  0 &amp; \text{if} \quad \mathtt{ECDSARECOVER}(h, v - 27, r, s) = \varnothing\\
  32 &amp; \text{otherwise}
\end{cases}\\
\text{if} \quad \lVert \mathbf{o} \rVert = 32: &amp;&amp;\\
\mathbf{o}[0..11] &amp;=&amp; 0 \\
\mathbf{o}[12..31] &amp;=&amp; \mathtt{KEC}\big(\mathtt{ECDSARECOVER}(h, v - 27, r, s)\big)[12..31] \quad \text{where:}\\
\mathbf{d}[0..(\lVert \hyperlink{I__d}{I_{\mathbf{d}}} \rVert-1)] &amp;=&amp; I_{\mathbf{d}}\\
\mathbf{d}[\lVert I_{\mathbf{d}} \rVert..] &amp;=&amp; (0, 0, ...) \\
h &amp;=&amp; \mathbf{d}[0..31]\\
v &amp;=&amp; \mathbf{d}[32..63]\\
r &amp;=&amp; \mathbf{d}[64..95]\\
s &amp;=&amp; \mathbf{d}[96..127]\end{aligned}$$</span><br /></p>
<p>We define <span class="math inline"><em>Ξ</em><sub><code>S</code><code>H</code><code>A</code><code>256</code></sub></span> and <span class="math inline"><em>Ξ</em><sub><code>R</code><code>I</code><code>P</code><code>160</code></sub></span> as precompiled contracts implementing the SHA2-256 and RIPEMD-160 hash functions respectively. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{SHA256}} &amp;\equiv&amp; \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_{\mathrm{r}} &amp;=&amp; 60 + 12\Big\lceil \dfrac{\lVert I_{\mathbf{d}} \rVert}{32} \Big\rceil\\
\mathbf{o}[0..31] &amp;=&amp; \mathtt{SHA256}(I_{\mathbf{d}})\\
\Xi_{\mathtt{RIP160}} &amp;\equiv&amp; \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_{\mathrm{r}} &amp;=&amp; 600 + 120\Big\lceil \dfrac{\lVert I_{\mathbf{d}} \rVert}{32} \Big\rceil\\
\mathbf{o}[0..11] &amp;=&amp; 0 \\
\mathbf{o}[12..31] &amp;=&amp; \mathtt{RIPEMD160}(I_{\mathbf{d}})\end{aligned}$$</span><br /></p>
<p>For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and SHA2-256 of the form:</p>
<p><br /><span class="math display">$$\begin{aligned}
\mathtt{SHA256}(\mathbf{i} \in \mathbb{B}) &amp; \equiv &amp; o \in \mathbb{B}_{32} \\
\mathtt{RIPEMD160}(\mathbf{i} \in \mathbb{B}) &amp; \equiv &amp; o \in \mathbb{B}_{20}\end{aligned}$$</span><br /></p>
<p>The fourth contract, the identity function <span class="math inline"><em>Ξ</em><sub><code>I</code><code>D</code></sub></span> simply defines the output as the input: <br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{ID}} &amp;\equiv&amp; \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_{\mathrm{r}} &amp;=&amp; 15 + 3\Big\lceil \dfrac{\lVert I_{\mathbf{d}} \rVert}{32} \Big\rceil\\
\mathbf{o} &amp;=&amp; I_{\mathbf{d}}\end{aligned}$$</span><br /></p>
<p>The fifth contract performs arbitrary-precision exponentiation under modulo. Here, <span class="math inline">0<sup>0</sup></span> is taken to be one, and <span class="math inline"><em>x</em> mod 0</span> is zero for all <span class="math inline"><em>x</em></span>. The first word in the input specifies the number of bytes that the first non-negative integer <span class="math inline"><em>B</em></span> occupies. The second word in the input specifies the number of bytes that the second non-negative integer <span class="math inline"><em>E</em></span> occupies. The third word in the input specifies the number of bytes that the third non-negative integer <span class="math inline"><em>M</em></span> occupies. These three words are followed by <span class="math inline"><em>B</em></span>, <span class="math inline"><em>E</em></span> and <span class="math inline"><em>M</em></span>. The rest of the input is discarded. Whenever the input is too short, the missing bytes are considered to be zero. The output is encoded big-endian into the same format as <span class="math inline"><em>M</em></span>’s.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{EXPMOD}} &amp;\equiv&amp; \Xi_{\mathtt{PRE}} \quad \text{except:} \\
g_{\mathrm{r}} &amp;=&amp; \max \left(200, \left\lfloor\frac{f\big(\max(\ell_{\mathrm{M}},\ell_{\mathrm{B}})\big)\max(\ell'_{\mathrm{E}},1)}{G_{\mathrm{quaddivisor}}}\right\rfloor \right) \\
G_{\mathrm{quaddivisor}} &amp;\equiv&amp; 3 \\
f(x) &amp;\equiv&amp; \left\lceil \frac{x}{8} \right\rceil ^2 \\
\ell'_{\mathrm{E}} &amp;=&amp; \begin{cases}
0 &amp; \text{if}\ \ell_{\mathrm{E}}\le 32\wedge E=0 \\
\lfloor \log_2(E)\rfloor &amp;\text{if}\ \ell_{\mathrm{E}}\le 32 \wedge E \neq 0 \\
8(\ell_{\mathrm{E}} - 32) + \lfloor \log_2(i[(96+\ell_{\mathrm{B}})..(127+\ell_{\mathrm{B}})]) \rfloor &amp; \text{if}\ 32 &lt; \ell_{\mathrm{E}} \wedge i[(96 + \ell_{\mathrm{B}})..(127 + \ell_{\mathrm{B}})]\neq 0 \\
8(\ell_{\mathrm{E}} - 32) &amp; \text{otherwise} \\
\end{cases} \\
\mathbf{o} &amp;=&amp; \left(B^E\bmod M\right)\in\mathbb{N}_{8\ell_{\mathrm{M}}} \\
\ell_{\mathrm{B}} &amp;\equiv&amp; i[0..31] \\
\ell_{\mathrm{E}} &amp;\equiv&amp; i[32..63] \\
\ell_{\mathrm{M}} &amp;\equiv&amp; i[64..95] \\
B &amp;\equiv&amp; i[96..(95+\ell_{\mathrm{B}})] \\
E &amp;\equiv&amp; i[(96+\ell_{\mathrm{B}})..(95+\ell_{\mathrm{B}}+\ell_{\mathrm{E}})] \\
M &amp;\equiv&amp; i[(96+\ell_{\mathrm{B}}+\ell_{\mathrm{E}})..(95+\ell_{\mathrm{B}}+\ell_{\mathrm{E}}+\ell_{\mathrm{M}})] \\
i[x] &amp;\equiv&amp; \begin{cases}
I_{\mathbf{d}}[x] &amp;\text{if}\ x &lt; \lVert I_{\mathbf{d}} \rVert \\
0 &amp;\text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<h2 id="zksnark-related-precompiled-contracts">zkSNARK Related Precompiled Contracts</h2>
<p>We choose two numbers, both of which are prime. <br /><span class="math display">$$\begin{aligned}
p &amp;\equiv&amp; 21888242871839275222246405745257275088696311157297823662689037894645226208583 \\
q &amp;\equiv&amp; 21888242871839275222246405745257275088548364400416034343698204186575808495617\end{aligned}$$</span><br /> Since <span class="math inline"><em>p</em></span> is a prime number, <span class="math inline">{0, 1, …, <em>p</em> − 1}</span> forms a field with addition and multiplication modulo <span class="math inline"><em>p</em></span>. We call this field <span class="math inline"><em>F</em><sub><em>p</em></sub></span>.</p>
<p>We define a set <span class="math inline"><em>C</em><sub>1</sub></span> with <br /><span class="math display"><em>C</em><sub>1</sub> ≡ {(<em>X</em>, <em>Y</em>) ∈ <em>F</em><sub><em>p</em></sub> × <em>F</em><sub><em>p</em></sub> ∣ <em>Y</em><sup>2</sup> = <em>X</em><sup>3</sup> + 3} ∪ {(0, 0)}</span><br /> We define a binary operation <span class="math inline">+</span> on <span class="math inline"><em>C</em><sub>1</sub></span> for distinct elements <span class="math inline">(<em>X</em><sub>1</sub>, <em>Y</em><sub>1</sub>), (<em>X</em><sub>2</sub>, <em>Y</em><sub>2</sub>)</span> with <br /><span class="math display">$$\begin{aligned}
\label{eq:ec-addition}
(X_1, Y_1) + (X_2, Y_2)&amp;\equiv&amp;\begin{cases}
(X,Y)&amp;\text{if}\ X_1\neq X_2\\
(0,0)&amp;\text{otherwise}
\end{cases}\\
\nonumber \lambda&amp;\equiv&amp;\frac{Y_2-Y_1}{X_2-X_1}\\
\nonumber X&amp;\equiv&amp;\lambda^2-X_1-X_2\\
\nonumber Y&amp;\equiv&amp;\lambda(X_1-X)-Y_1\end{aligned}$$</span><br /></p>
<p>In the case where <span class="math inline">(<em>X</em><sub>1</sub>, <em>Y</em><sub>1</sub>) = (<em>X</em><sub>2</sub>, <em>Y</em><sub>2</sub>)</span>, we define <span class="math inline">+</span> on <span class="math inline"><em>C</em><sub>1</sub></span> with <br /><span class="math display">$$\begin{aligned}
\label{eq:ec-doubling}
(X_1, Y_1) + (X_2, Y_2)&amp;\equiv&amp;\begin{cases}
(X,Y)&amp;\text{if}\ Y_1\neq 0\\
(0,0)&amp;\text{otherwise}
\end{cases}\\
\nonumber \lambda&amp;\equiv&amp;\frac{3X_1^2}{2Y_1}\\
\nonumber X&amp;\equiv&amp;\lambda^2-2X_1\\
\nonumber Y&amp;\equiv&amp;\lambda(X_1-X)-Y_1\end{aligned}$$</span><br /></p>
<p><span class="math inline">(<em>C</em><sub>1</sub>,  + )</span> is known to form a group. We define scalar multiplication <span class="math inline">⋅</span> with <br /><span class="math display">$$\label{eq:ec-scalar-multiplication}
n\cdot P\equiv(0,0)+\underbrace{P+\cdots+P}_{n}$$</span><br /> for a natural number <span class="math inline"><em>n</em></span> and a point <span class="math inline"><em>P</em></span> in <span class="math inline"><em>C</em><sub>1</sub></span>.</p>
<p>We define <span class="math inline"><em>P</em><sub>1</sub></span> to be a point <span class="math inline">(1, 2)</span> on <span class="math inline"><em>C</em><sub>1</sub></span>. Let <span class="math inline"><em>G</em><sub>1</sub></span> be the subgroup of <span class="math inline">(<em>C</em><sub>1</sub>,  + )</span> generated by <span class="math inline"><em>P</em><sub>1</sub></span>. <span class="math inline"><em>G</em><sub>1</sub></span> is known to be a cyclic group of order <span class="math inline"><em>q</em></span>. For a point <span class="math inline"><em>P</em></span> in <span class="math inline"><em>G</em><sub>1</sub></span>, we define <span class="math inline">log<sub><em>P</em><sub>1</sub></sub>(<em>P</em>)</span> to be the smallest natural number <span class="math inline"><em>n</em></span> satisfying <span class="math inline"><em>n</em> ⋅ <em>P</em><sub>1</sub> = <em>P</em></span>. <span class="math inline">log<sub><em>P</em><sub>1</sub></sub>(<em>P</em>)</span> is at most <span class="math inline"><em>q</em> − 1</span>.</p>
<p>Let <span class="math inline"><em>F</em><sub><em>p</em><sup>2</sup></sub></span> be a field <span class="math inline"><em>F</em><sub><em>p</em></sub>[<em>i</em>]/(<em>i</em><sup>2</sup> + 1)</span>. We define a set <span class="math inline"><em>C</em><sub>2</sub></span> with <br /><span class="math display"><em>C</em><sub>2</sub> ≡ {(<em>X</em>, <em>Y</em>) ∈ <em>F</em><sub><em>p</em><sup>2</sup></sub> × <em>F</em><sub><em>p</em><sup>2</sup></sub> ∣ <em>Y</em><sup>2</sup> = <em>X</em><sup>3</sup> + 3(<em>i</em> + 9)<sup> − 1</sup>} ∪ {(0, 0)}</span><br /> We define a binary operation <span class="math inline">+</span> and scalar multiplication <span class="math inline">⋅</span> with the same equations (<a href="#eq:ec-addition" data-reference-type="ref" data-reference="eq:ec-addition">[eq:ec-addition]</a>), (<a href="#eq:ec-doubling" data-reference-type="ref" data-reference="eq:ec-doubling">[eq:ec-doubling]</a>) and (<a href="#eq:ec-scalar-multiplication" data-reference-type="ref" data-reference="eq:ec-scalar-multiplication">[eq:ec-scalar-multiplication]</a>). <span class="math inline">(<em>C</em><sub>2</sub>,  + )</span> is also known to be a group. We define <span class="math inline"><em>P</em><sub>2</sub></span> in <span class="math inline"><em>C</em><sub>2</sub></span> with <br /><span class="math display">$$\begin{aligned}
P_2&amp;\equiv&amp;
(11559732032986387107991004021392285783925812861821192530917403151452391805634 \times i\\\nonumber &amp;&amp;+ 10857046999023057135944570762232829481370756359578518086990519993285655852781,\\\nonumber &amp;&amp; 4082367875863433681332203403145435568316851327593401208105741076214120093531 \times i\\\nonumber &amp;&amp;+ 8495653923123431417604973247489272438418190587263600148770280649306958101930)\end{aligned}$$</span><br /> We define <span class="math inline"><em>G</em><sub>2</sub></span> to be the subgroup of <span class="math inline">(<em>C</em><sub>2</sub>,  + )</span> generated by <span class="math inline"><em>P</em><sub>2</sub></span>. <span class="math inline"><em>G</em><sub>2</sub></span> is known to be the only cyclic group of order <span class="math inline"><em>q</em></span> on <span class="math inline"><em>C</em><sub>2</sub></span>. For a point <span class="math inline"><em>P</em></span> in <span class="math inline"><em>G</em><sub>2</sub></span>, we define <span class="math inline">log<sub><em>P</em><sub>2</sub></sub>(<em>P</em>)</span> be the smallest natural number <span class="math inline"><em>n</em></span> satisfying <span class="math inline"><em>n</em> ⋅ <em>P</em><sub>2</sub> = <em>P</em></span>. With this definition, <span class="math inline">log<sub><em>P</em><sub>2</sub></sub>(<em>P</em>)</span> is at most <span class="math inline"><em>q</em> − 1</span>.</p>
<p>Let <span class="math inline"><em>G</em><sub><em>T</em></sub></span> be the multiplicative abelian group underlying <span class="math inline"><em>F</em><sub><em>q</em><sup>12</sup></sub></span>. It is known that a non-degenerate bilinear map <span class="math inline"><em>e</em> : <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub> → <em>G</em><sub><em>T</em></sub></span> exists. This bilinear map is a type three pairing. There are several such bilinear maps, it does not matter which is chosen to be <span class="math inline"><em>e</em></span>. Let <span class="math inline"><em>P</em><sub><em>T</em></sub> = <em>e</em>(<em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>)</span>, <span class="math inline"><em>a</em></span> be a set of <span class="math inline"><em>k</em></span> points in <span class="math inline"><em>G</em><sub>1</sub></span>, and <span class="math inline"><em>b</em></span> be a set of <span class="math inline"><em>k</em></span> points in <span class="math inline"><em>G</em><sub>2</sub></span>. It follows from the definition of a pairing that the following are equivalent <br /><span class="math display">$$\begin{aligned}
 \label{eq:pairing-check}
\log_{P_1}(a_1)\times\log_{P_2}(b_1)+\cdots+\log_{P_1}(a_{k})\times\log_{P_2}(b_{k})&amp;\equiv&amp; 1\mod q\\
\prod_{i=0}^{k}e\left(a_i, b_i\right) &amp;=&amp; P_T\end{aligned}$$</span><br /> Thus the pairing operation provides a method to verify (<a href="#eq:pairing-check" data-reference-type="ref" data-reference="eq:pairing-check">[eq:pairing-check]</a>).</p>
<p>A 32 byte number <span class="math inline"><strong>x</strong> ∈ <strong>P</strong><sub>256</sub></span> might and might not represent an element of <span class="math inline"><em>F</em><sub><em>p</em></sub></span>. <br /><span class="math display">$$\delta_{\mathrm{p}}(\mathbf{x})\equiv\begin{cases}
\mathbf{x}&amp;\text{if}\ \mathbf{x}&lt;p\\
\varnothing&amp;\text{otherwise}
\end{cases}$$</span><br /></p>
<p>A 64 byte data <span class="math inline"><strong>x</strong> ∈ <strong>B</strong><sub>512</sub></span> might and might not represent an element of <span class="math inline"><em>G</em><sub>1</sub></span>. <br /><span class="math display">$$\begin{aligned}
\delta_1(\mathbf{x})&amp;\equiv&amp;\begin{cases}
g_1&amp;\text{if}\ g_1\in G_1\\
\varnothing&amp;\text{otherwise}
\end{cases}\\
g_1&amp;\equiv&amp;\begin{cases}
(x,y)&amp;\text{if}\ x\neq\varnothing\wedge y\neq\varnothing\\
\varnothing&amp;\text{otherwise}
\end{cases}\\
x&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[0..31])\\
y&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[32..63])\end{aligned}$$</span><br /></p>
<p>A 128 byte data <span class="math inline"><strong>x</strong> ∈ <strong>B</strong><sub>1024</sub></span> might and might not represent an element of <span class="math inline"><em>G</em><sub>2</sub></span>. <br /><span class="math display">$$\begin{aligned}
\delta_2(\mathbf{x})&amp;\equiv&amp;\begin{cases}
g_2&amp;\text{if}\ g_2\in G_2\\
\varnothing&amp;\text{otherwise}
\end{cases}\\
g_2&amp;\equiv&amp;\begin{cases}
((x_0i+y_0),(x_1i+y_1))&amp;\text{if}\ x_0\neq\varnothing\wedge y_0\neq\varnothing\wedge x_1\neq\varnothing\wedge y_1\neq\varnothing\\
\varnothing&amp;\text{otherwise}
\end{cases}\\
x_0&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[0..31])\\
y_0&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[32..63])\\
x_1&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[64..95])\\
y_1&amp;\equiv&amp;\delta_{\mathrm{p}}(\mathbf{x}[96..127])\end{aligned}$$</span><br /></p>
<p>We define <span class="math inline"><em>Ξ</em><sub><code>S</code><code>N</code><code>A</code><code>R</code><code>K</code><code>V</code></sub></span> as a precompiled contract which checks if (<a href="#eq:pairing-check" data-reference-type="ref" data-reference="eq:pairing-check">[eq:pairing-check]</a>) holds, for intended use in zkSNARK verification.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{SNARKV}}&amp;\equiv&amp;\Xi_{\mathtt{PRE}}\quad\text{except:}\\
\qquad\Xi_{\mathtt{SNARKV}}(\boldsymbol\sigma,g,A,I)&amp;=&amp;\left(\varnothing,0,A,()\right)\quad\text{if}\ F\\
F&amp;\equiv&amp;(\lVert I_{\mathbf{d}} \rVert\bmod 192\neq 0\vee(\exists j.\ a_{\mathrm{j}}=\varnothing\vee b_{\mathrm{j}}=\varnothing))\\
k &amp;=&amp; \dfrac{\lVert I_{\mathbf{d}} \rVert}{192} \\
g_{\mathrm{r}}&amp;=&amp; 34000k + 45000 \\
\mathbf{o}[0..31]&amp;\equiv&amp;\begin{cases}
0x0000000000000000000000000000000000000000000000000000000000000001&amp;\text{if}\ v\wedge\neg F\\
0x0000000000000000000000000000000000000000000000000000000000000000&amp;\text{if}\ \neg v\wedge\neg F
\end{cases}\\
v&amp;\equiv&amp;(\log_{P_1}(a_1)\times\log_{P_2}(b_1)+\cdots+\log_{P_1}(a_k)\times\log_{P_2}(b_k)\equiv 1\mod q)\\
a_1&amp;\equiv&amp;\delta_1(I_{\mathbf{d}}[0..63])\\
b_1&amp;\equiv&amp;\delta_2(I_{\mathbf{d}}[64..191])\\\nonumber
\vdots\\
a_k&amp;\equiv&amp;\delta_1(I_{\mathbf{d}}[(\lVert I_{\mathbf{d}} \rVert-192)..(\lVert I_{\mathbf{d}} \rVert-129)])\\
b_k&amp;\equiv&amp;\delta_2(I_{\mathbf{d}}[(\lVert I_{\mathbf{d}} \rVert-128)..(\lVert I_{\mathbf{d}} \rVert-1)])\end{aligned}$$</span><br /></p>
<p>We define a precompiled contract for addition on <span class="math inline"><em>G</em><sub>1</sub></span>.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{BN\_ADD}}&amp;\equiv&amp;\Xi_{\mathtt{BN\_PRE}}\quad\text{except:}\\
\Xi_{\mathtt{BN\_ADD}}(\boldsymbol\sigma,g,A,I)&amp;=&amp;\left(\varnothing,0,A,()\right)\quad\text{if}\ x=\varnothing\vee y=\varnothing\\
g_{\mathrm{r}} &amp;=&amp; 150\\
\mathbf{o}&amp;\equiv&amp;\delta_1^{-1}(x+y)\quad\text{where $+$ is the group operation in $G_1$}\\
x&amp;\equiv&amp;\delta_1\left(\bar I_{\mathbf{d}}[0..63]\right)\\
y&amp;\equiv&amp;\delta_1\left(\bar I_{\mathbf{d}}[64..127]\right)\\
\label{eq:complemented_input}\bar I_{\mathbf{d}}[x]&amp;\equiv&amp;\begin{cases}
I_{\mathbf{d}}[x]&amp;\text{if}\ x &lt; \lVert I_{\mathbf{d}} \rVert\\
0&amp;\text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<p>We define a precompiled contract for scalar multiplication on <span class="math inline"><em>G</em><sub>1</sub></span>, where <span class="math inline"><em>Ī</em><sub><strong>d</strong></sub></span> is defined in (<a href="#eq:complemented_input" data-reference-type="ref" data-reference="eq:complemented_input">[eq:complemented_input]</a>). <br /><span class="math display">$$\begin{aligned}
\Xi_{\mathtt{BN\_MUL}}&amp;\equiv&amp;\Xi_{\mathtt{PRE}}\quad\text{except:}\\
\Xi_{\mathtt{BN\_MUL}}(\boldsymbol\sigma,g,A,I)&amp;=&amp;\left(\varnothing,0,A,()\right)\quad\text{if}\ x=\varnothing\\
g_{\mathrm{r}} &amp;=&amp; 6000\\
\mathbf{o}&amp;\equiv&amp;\delta_1^{-1}(n\cdot x)\quad\text{where $\cdot$ is the scalar multiplication in $G_1$}\\
x&amp;\equiv&amp;\delta_1\left(\bar I_{\mathbf{d}}[0..63]\right)\\
n&amp;\equiv&amp;\bar I_{\mathbf{d}}[64..95]\end{aligned}$$</span><br /></p>
<h2 id="blake2-precompiled-contract">BLAKE2 Precompiled Contract</h2>
<p>EIP-152 by <span class="citation" data-cites="EIP-152"></span> defines <span class="math inline"><em>Ξ</em><sub><code>B</code><code>L</code><code>A</code><code>K</code><code>E</code><code>2</code><code>_</code><code>F</code></sub></span> as a precompiled contract implementing the compression function <span class="math inline"><code>F</code></span> used in the BLAKE2 cryptographic hashing algorithm. The <span class="math inline"><code>F</code></span> compression function is specified in RFC 7693 by <span class="citation" data-cites="RFC-7693"></span>. <br /><span class="math display">$$\begin{aligned}
  \Xi_{\mathtt{BLAKE2\_F}}&amp;\equiv&amp;\Xi_{\mathtt{PRE}}\quad\text{except:}\\
  \Xi_{\mathtt{BLAKE2\_F}}(\boldsymbol\sigma,g,A,I)&amp;=&amp;\left(\varnothing,0,A,()\right)\quad\text{if}\ \lVert I_{\mathbf{d}}\rVert \neq 213 \vee f \notin \{0, 1\} \\
  g_{\mathrm{r}} &amp;=&amp; r\\
  \mathbf{o} &amp;\equiv&amp; \mathtt{LE}_8(h'_0)\cdot ... \cdot \mathtt{LE}_8(h'_7) \\
  (h'_0,\dots,h'_7) &amp;\equiv&amp; \mathtt{F}(h, m, t_\mathrm{low}, t_\mathrm{high}, f) \quad\text{with } r \text{ rounds and } w = 64 \\
  \mathtt{BE}_4(r) &amp;\equiv&amp; I_{\mathbf{d}}[0..4] \\
  \mathtt{LE}_8(h_0) &amp;\equiv&amp; I_{\mathbf{d}}[4..12] \\
  &amp;\dots&amp; \\
  \mathtt{LE}_8(h_7) &amp;\equiv&amp; I_{\mathbf{d}}[60..68] \\
  \mathtt{LE}_8(m_0) &amp;\equiv&amp; I_{\mathbf{d}}[68..76] \\
  &amp;\dots&amp; \\
  \mathtt{LE}_8(m_{15}) &amp;\equiv&amp; I_{\mathbf{d}}[188..196] \\
  \mathtt{LE}_8(t_\mathrm{low}) &amp;\equiv&amp; I_{\mathbf{d}}[196..204] \\
  \mathtt{LE}_8(t_\mathrm{high}) &amp;\equiv&amp; I_{\mathbf{d}}[204..212] \\
  f &amp;\equiv&amp; I_{\mathbf{d}}[212]\end{aligned}$$</span><br /> where <span class="math inline"><em>r</em> ∈ 𝔹<sub>32</sub></span>, <span class="math inline">∀<em>i</em> ∈ 0..7 : <em>h</em><sub><em>i</em></sub> ∈ 𝔹<sub>64</sub></span>, <span class="math inline">∀<em>i</em> ∈ 0..15 : <em>m</em><sub><em>i</em></sub> ∈ 𝔹<sub>64</sub></span>, <span class="math inline"><em>t</em><sub><em>l</em><em>o</em><em>w</em></sub> ∈ 𝔹<sub>64</sub></span>, <span class="math inline"><em>t</em><sub><em>h</em><em>i</em><em>g</em><em>h</em></sub> ∈ 𝔹<sub>64</sub></span>, <span class="math inline"><em>f</em> ∈ 𝔹<sub>8</sub></span>, <span class="math inline"><code>B</code><code>E</code><sub><em>k</em></sub></span> is the <span class="math inline"><em>k</em></span>-byte big-endian representation—compare with(<a href="#eq:BE" data-reference-type="ref" data-reference="eq:BE">[eq:BE]</a>): <br /><span class="math display">$$\mathtt{BE}_k(x) \equiv (b_0, b_1, ..., b_{k-1}): x = \sum_{n = 0}^{k-1} b_n \cdot 256^{k-1-n}$$</span><br /> and <span class="math inline"><code>L</code><code>E</code><sub><em>k</em></sub></span> is the <span class="math inline"><em>k</em></span>-byte little-endian representation: <br /><span class="math display">$$\mathtt{LE}_k(x) \equiv (b_0, b_1, ..., b_{k-1}): x = \sum_{n = 0}^{k-1} b_n \cdot 256^n$$</span><br /></p>
<h1 id="app:signing">Signing Transactions</h1>
<p>Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve as described by <span class="citation" data-cites="Courtois2014"></span>, and is implemented similarly to as described by <span class="citation" data-cites="gura2004comparing"></span> on p. 9 of 15, para. 3.</p>
<p>It is assumed that the sender has a valid private key <span class="math inline"><em>p</em><sub><em>r</em></sub></span>, which is a randomly selected positive integer (represented as a byte array of length 32 in big-endian form) in the range <span class="math inline">[1, <code>s</code><code>e</code><code>c</code><code>p</code><code>256</code><code>k</code><code>1</code><code>n</code> − 1]</span>.</p>
<p>We assume the existence of functions <span class="math inline"><code>E</code><code>C</code><code>D</code><code>S</code><code>A</code><code>P</code><code>U</code><code>B</code><code>K</code><code>E</code><code>Y</code></span>, <span class="math inline"><code>E</code><code>C</code><code>D</code><code>S</code><code>A</code><code>S</code><code>I</code><code>G</code><code>N</code></span> and <span class="math inline"><code>E</code><code>C</code><code>D</code><code>S</code><code>A</code><code>R</code><code>E</code><code>C</code><code>O</code><code>V</code><code>E</code><code>R</code></span>. These are formally defined in the literature, e.g. by <span class="citation" data-cites="ECDSAcerticom"></span>. <br /><span class="math display">$$\begin{aligned}
\mathtt{ECDSAPUBKEY}(p_{\mathrm{r}} \in \mathbb{B}_{32}) &amp; \equiv &amp; p_{\mathrm{u}} \in \mathbb{B}_{64} \\
\Hy@raisedlink{\hypertarget{ECDSASIGN}{}}\mathtt{ECDSASIGN}(e \in \mathbb{B}_{32}, p_{\mathrm{r}} \in \mathbb{B}_{32}) &amp; \equiv &amp; (v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) \\
\mathtt{ECDSARECOVER}(e \in \mathbb{B}_{32}, v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) &amp; \equiv &amp; p_{\mathrm{u}} \in \mathbb{B}_{64}\end{aligned}$$</span><br /></p>
<p>Where <span class="math inline"><em>p</em><sub><em>u</em></sub></span> is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive integers each <span class="math inline"> &lt; 2<sup>256</sup></span>), <span class="math inline"><em>p</em><sub><em>r</em></sub></span> is the private key, a byte array of size 32 (or a single positive integer in the aforementioned range) and <span class="math inline"><em>e</em></span> is the hash of the transaction, <a href="#h_of_T"><span class="math inline"><em>h</em>(<em>T</em>)</span></a>. It is assumed that <span id="v"></span><span class="math inline"><em>v</em></span> is the ‘recovery identifier’. The recovery identifier is a 1 byte value specifying the parity and finiteness of the coordinates of the curve point for which <span class="math inline"><em>r</em></span> is the x-value; this value is in the range of <span class="math inline">[0, 3]</span>, however we declare the upper two possibilities, representing infinite values, invalid. The value 0 represents an even <span class="math inline"><em>y</em></span> value and 1 represents an odd <span class="math inline"><em>y</em></span> value.</p>
<p>We declare that an ECDSA signature is invalid unless all the following conditions are true: <br /><span class="math display">$$\begin{aligned}
0 &lt; \Hy@raisedlink{\hypertarget{r}{}}{r} &amp;&lt; \mathtt{secp256k1n} \\
0 &lt; \Hy@raisedlink{\hypertarget{s}{}}{s} &amp;&lt; \mathtt{secp256k1n} \div 2 + 1 \\
\hyperlink{v}{v} &amp;\in \{0,1\}\end{aligned}$$</span><br /> where: <br /><span class="math display">$$\begin{aligned}
\mathtt{secp256k1n} &amp;= 115792089237316195423570985008687907852837564279074904382605163141518161494337
%\mathtt{secp256k1p} &amp;= 2^{256} - 2^{32} - 977\\\end{aligned}$$</span><br /> Note that this restriction on <span class="math inline"><em>s</em></span> is more stringent than restriction <a href="#eq:ecrec_precompile_validity" data-reference-type="ref" data-reference="eq:ecrec_precompile_validity">[eq:ecrec_precompile_validity]</a> in the <span class="math inline"><em>Ξ</em><sub><code>E</code><code>C</code><code>R</code><code>E</code><code>C</code></sub></span> precompile; see EIP-2 by <span class="citation" data-cites="EIP-2"></span> for more detail.</p>
<p>For a given private key, <span class="math inline"><em>p</em><sub><em>r</em></sub></span>, the Ethereum address <span class="math inline"><em>A</em>(<em>p</em><sub><em>r</em></sub>)</span> (a 160-bit value) to which it corresponds is defined as the rightmost 160-bits of the Keccak-256 hash of the corresponding ECDSA public key: <br /><span class="math display"><em>A</em>(<em>p</em><sub><em>r</em></sub>) = ℬ<sub>96..255</sub>(<code>K</code><code>E</code><code>C</code>(<code>E</code><code>C</code><code>D</code><code>S</code><code>A</code><code>P</code><code>U</code><code>B</code><code>K</code><code>E</code><code>Y</code>(<em>p</em><sub><em>r</em></sub>)))</span><br /></p>
<div id="h_of_T">

</div>
<p>The message hash, <span class="math inline"><em>h</em>(<em>T</em>)</span>, to be signed is the Keccak-256 hash of the transaction. Three different flavours of signing schemes are available: <br /><span class="math display">$$\begin{aligned}
L_{\mathrm{X}}(T) &amp; \equiv &amp; \begin{cases}
(T_{\mathrm{n}}, T_{\mathrm{p}}, T_{\mathrm{g}}, T_{\mathrm{t}}, T_{\mathrm{v}}, \mathbf{p}) &amp; \text{if} \; T_{\mathrm{x}} = 0 \land T_{\mathrm{w}} \in \{27, 28\} \\
(T_{\mathrm{n}}, T_{\mathrm{p}}, T_{\mathrm{g}}, T_{\mathrm{t}}, T_{\mathrm{v}}, \mathbf{p}, \beta, (), ()) &amp; \text{if} \; T_{\mathrm{x}} = 0 \land T_{\mathrm{w}} \in \{2\beta + 35, 2\beta + 36\} \\
(T_{\mathrm{c}}, T_{\mathrm{n}}, T_{\mathrm{p}}, T_{\mathrm{g}}, T_{\mathrm{t}}, T_{\mathrm{v}}, \mathbf{p}, T_{\mathbf{A}}) &amp; \text{if} \; T_{\mathrm{x}} = 1
\end{cases} \\
\nonumber \text{where} \\
\nonumber \mathbf{p} &amp; \equiv &amp; \begin{cases}
T_{\mathbf{i}} &amp; \text{if}\ T_{\mathrm{t}} = \varnothing \\
T_{\mathbf{d}} &amp; \text{otherwise}
\end{cases} \\
h(T) &amp; \equiv &amp; \begin{cases}
\mathtt{KEC}( \mathtt{RLP}(L_{\mathrm{X}}(T)) ) &amp; \text{if} \; T_{\mathrm{x}} = 0 \\
\mathtt{KEC}( T_{\mathrm{x}} \cdot \mathtt{RLP}(L_{\mathrm{X}}(T)) ) &amp; \text{otherwise}
\end{cases}\end{aligned}$$</span><br /></p>
<p>The signed transaction <span class="math inline"><em>G</em>(<em>T</em>, <em>p</em><sub><em>r</em></sub>)</span> is defined as: <br /><span class="math display">$$\begin{aligned}
G(T, p_{\mathrm{r}}) \equiv T \quad \text{except:} \\
(T_{\mathrm{y}}, T_{\mathrm{r}}, T_{\mathrm{s}}) = \mathtt{ECDSASIGN}(h(T), p_{\mathrm{r}})\end{aligned}$$</span><br /></p>
<p><a href="#T__r_T__s">Reiterating from previously</a>: <br /><span class="math display">$$\begin{aligned}
\Hy@raisedlink{\hypertarget{T__r}{}}{T_{\mathrm{r}}} = \hyperlink{r}{r}\\
\Hy@raisedlink{\hypertarget{T__s}{}}{T_{\mathrm{s}}} = \hyperlink{s}{s}\end{aligned}$$</span><br /> and <span class="math inline">$\hyperlink{T__w}{T_{\mathrm{w}}}$</span> of legacy transcations is either <span class="math inline">27 + <em>T</em><sub><em>y</em></sub></span> or <span class="math inline">$2\hyperlink{chain_id}{\beta} + 35 + T_{\mathrm{y}}$</span>.</p>
<p>We may then define the sender function <span class="math inline"><em>S</em></span> of the transaction as: <br /><span class="math display">$$\begin{aligned}
S(T) &amp;\equiv&amp; \mathcal{B}_{96..255}\big(\mathtt{KEC}\big( \mathtt{ECDSARECOVER}(h(T), v, T_{\mathrm{r}}, T_{\mathrm{s}}) \big) \big) \\
v &amp;\equiv&amp; \begin{cases}
T_{\mathrm{w}} - 27 &amp; \text{if} \; T_{\mathrm{x}} = 0 \land T_{\mathrm{w}} \in \{27, 28\} \\
(T_{\mathrm{w}}-35) \bmod 2 &amp; \text{if} \ T_{\mathrm{x}} = 0 \land T_{\mathrm{w}} \in \{2\beta + 35, 2\beta + 36\} \\
T_{\mathrm{y}} &amp; \text{if} \ T_{\mathrm{x}} = 1
\end{cases}\end{aligned}$$</span><br /></p>
<p>The assertion that the sender of a signed transaction equals the address of the signer should be self-evident: <br /><span class="math display">∀<em>T</em> : ∀<em>p</em><sub><em>r</em></sub> : <em>S</em>(<em>G</em>(<em>T</em>, <em>p</em><sub><em>r</em></sub>)) ≡ <em>A</em>(<em>p</em><sub><em>r</em></sub>)</span><br /></p>
<h1 id="app:fees">Fee Schedule</h1>
<p>The fee schedule <span class="math inline"><em>G</em></span> is a tuple of scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.</p>
<p><span>l r l</span> Name &amp; Value &amp; Description<br />
<span class="math inline"><em>G</em><sub><em>z</em><em>e</em><em>r</em><em>o</em></sub></span> &amp; 0 &amp; Nothing paid for operations of the set <span><span class="math inline"><em>W</em><sub><em>z</em><em>e</em><em>r</em><em>o</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>j</em><em>u</em><em>m</em><em>p</em><em>d</em><em>e</em><em>s</em><em>t</em></sub></span> &amp; 1 &amp; Amount of gas to pay for a <span>JUMPDEST</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>b</em><em>a</em><em>s</em><em>e</em></sub></span> &amp; 2 &amp; Amount of gas to pay for operations of the set <span><span class="math inline"><em>W</em><sub><em>b</em><em>a</em><em>s</em><em>e</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>v</em><em>e</em><em>r</em><em>y</em><em>l</em><em>o</em><em>w</em></sub></span> &amp; 3 &amp; Amount of gas to pay for operations of the set <span><span class="math inline"><em>W</em><sub><em>v</em><em>e</em><em>r</em><em>y</em><em>l</em><em>o</em><em>w</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>l</em><em>o</em><em>w</em></sub></span> &amp; 5 &amp; Amount of gas to pay for operations of the set <span><span class="math inline"><em>W</em><sub><em>l</em><em>o</em><em>w</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>m</em><em>i</em><em>d</em></sub></span> &amp; 8 &amp; Amount of gas to pay for operations of the set <span><span class="math inline"><em>W</em><sub><em>m</em><em>i</em><em>d</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>h</em><em>i</em><em>g</em><em>h</em></sub></span> &amp; 10 &amp; Amount of gas to pay for operations of the set <span><span class="math inline"><em>W</em><sub><em>h</em><em>i</em><em>g</em><em>h</em></sub></span></span>.<br />
<span class="math inline"><em>G</em><sub><em>w</em><em>a</em><em>r</em><em>m</em><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em></sub></span> &amp; 100 &amp; Cost of a warm account or storage access.<br />
<span class="math inline"><em>G</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em><em>l</em><em>i</em><em>s</em><em>t</em><em>a</em><em>d</em><em>d</em><em>r</em><em>e</em><em>s</em><em>s</em></sub></span> &amp; 2400 &amp; Cost of warming up an account with the access list.<br />
<span class="math inline"><em>G</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>t</em><em>o</em><em>r</em><em>a</em><em>g</em><em>e</em></sub></span> &amp; 1900 &amp; Cost of warming up a storage with the access list.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>o</em><em>l</em><em>d</em><em>a</em><em>c</em><em>c</em><em>o</em><em>u</em><em>n</em><em>t</em><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em></sub></span> &amp; 2600 &amp; Cost of a cold account access.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>o</em><em>l</em><em>d</em><em>s</em><em>l</em><em>o</em><em>a</em><em>d</em></sub></span> &amp; 2100 &amp; Cost of a cold storage access.<br />
<span class="math inline"><em>G</em><sub><em>s</em><em>s</em><em>e</em><em>t</em></sub></span> &amp; 20000 &amp; Paid for an <span>SSTORE</span> operation when the storage value is set to non-zero from zero.<br />
<span class="math inline"><em>G</em><sub><em>s</em><em>r</em><em>e</em><em>s</em><em>e</em><em>t</em></sub></span> &amp; 2900 &amp; Paid for an <span>SSTORE</span> operation when the storage value’s zeroness remains unchanged or<br />
&amp;&amp;is set to zero.<br />
<span class="math inline"><em>R</em><sub><em>s</em><em>c</em><em>l</em><em>e</em><em>a</em><em>r</em></sub></span> &amp; 15000 &amp; Refund given (added into refund counter) when the storage value is set to zero from<br />
&amp;&amp;non-zero.<br />
<span class="math inline"><em>R</em><sub><em>s</em><em>e</em><em>l</em><em>f</em><em>d</em><em>e</em><em>s</em><em>t</em><em>r</em><em>u</em><em>c</em><em>t</em></sub></span> &amp; 24000 &amp; Refund given (added into refund counter) for self-destructing an account.<br />
<span class="math inline"><em>G</em><sub><em>s</em><em>e</em><em>l</em><em>f</em><em>d</em><em>e</em><em>s</em><em>t</em><em>r</em><em>u</em><em>c</em><em>t</em></sub></span> &amp; 5000 &amp; Amount of gas to pay for a <span>SELFDESTRUCT</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em></sub></span> &amp; 32000 &amp; Paid for a <span>CREATE</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>o</em><em>d</em><em>e</em><em>d</em><em>e</em><em>p</em><em>o</em><em>s</em><em>i</em><em>t</em></sub></span> &amp; 200 &amp; Paid per byte for a <span>CREATE</span> operation to succeed in placing code into state.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>a</em><em>l</em><em>l</em><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></sub></span> &amp; 9000 &amp; Paid for a non-zero value transfer as part of the <span>CALL</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>a</em><em>l</em><em>l</em><em>s</em><em>t</em><em>i</em><em>p</em><em>e</em><em>n</em><em>d</em></sub></span> &amp; 2300 &amp; A stipend for the called contract subtracted from <span class="math inline"><em>G</em><sub><em>c</em><em>a</em><em>l</em><em>l</em><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></sub></span> for a non-zero value transfer.<br />
<span class="math inline"><em>G</em><sub><em>n</em><em>e</em><em>w</em><em>a</em><em>c</em><em>c</em><em>o</em><em>u</em><em>n</em><em>t</em></sub></span> &amp; 25000 &amp; Paid for a <span>CALL</span> or <span>SELFDESTRUCT</span> operation which creates an account.<br />
<span class="math inline"><em>G</em><sub><em>e</em><em>x</em><em>p</em></sub></span> &amp; 10 &amp; Partial payment for an <span>EXP</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>e</em><em>x</em><em>p</em><em>b</em><em>y</em><em>t</em><em>e</em></sub></span> &amp; 50 &amp; Partial payment when multiplied by the number of bytes in the exponent for the <span>EXP</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>m</em><em>e</em><em>m</em><em>o</em><em>r</em><em>y</em></sub></span> &amp; 3 &amp; Paid for every additional word when expanding memory.<br />
<span class="math inline"><em>G</em><sub>txcreate</sub></span> &amp; 32000 &amp; Paid by all contract-creating transactions after the <span><em>Homestead</em> transition</span>.<br />
<span class="math inline"><em>G</em><sub><em>t</em><em>x</em><em>d</em><em>a</em><em>t</em><em>a</em><em>z</em><em>e</em><em>r</em><em>o</em></sub></span> &amp; 4 &amp; Paid for every zero byte of data or code for a transaction.<br />
<span class="math inline"><em>G</em><sub><em>t</em><em>x</em><em>d</em><em>a</em><em>t</em><em>a</em><em>n</em><em>o</em><em>n</em><em>z</em><em>e</em><em>r</em><em>o</em></sub></span> &amp; 16 &amp; Paid for every non-zero byte of data or code for a transaction.<br />
<span class="math inline"><em>G</em><sub><em>t</em><em>r</em><em>a</em><em>n</em><em>s</em><em>a</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em></sub></span> &amp; 21000 &amp; Paid for every transaction.<br />
<span class="math inline"><em>G</em><sub><em>l</em><em>o</em><em>g</em></sub></span> &amp; 375 &amp; Partial payment for a <span>LOG</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>l</em><em>o</em><em>g</em><em>d</em><em>a</em><em>t</em><em>a</em></sub></span> &amp; 8 &amp; Paid for each byte in a <span>LOG</span> operation’s data.<br />
<span class="math inline"><em>G</em><sub><em>l</em><em>o</em><em>g</em><em>t</em><em>o</em><em>p</em><em>i</em><em>c</em></sub></span> &amp; 375 &amp; Paid for each topic of a <span>LOG</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>k</em><em>e</em><em>c</em><em>c</em><em>a</em><em>k</em>256</sub></span> &amp; 30 &amp; Paid for each <span>KECCAK256</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>k</em><em>e</em><em>c</em><em>c</em><em>a</em><em>k</em>256<em>w</em><em>o</em><em>r</em><em>d</em></sub></span> &amp; 6 &amp; Paid for each word (rounded up) for input data to a <span>KECCAK256</span> operation.<br />
<span class="math inline"><em>G</em><sub><em>c</em><em>o</em><em>p</em><em>y</em></sub></span> &amp; 3 &amp; Partial payment for <span>COPY</span> operations, multiplied by words copied, rounded up.<br />
<span class="math inline"><em>G</em><sub><em>b</em><em>l</em><em>o</em><em>c</em><em>k</em><em>h</em><em>a</em><em>s</em><em>h</em></sub></span> &amp; 20 &amp; Payment for each <span>BLOCKHASH</span> operation.<br />
</p>
<h1 id="app:vm">Virtual Machine Specification</h1>
<p>When interpreting 256-bit binary values as integers, the representation is big-endian.</p>
<p>When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE) 20 bytes are used and the leftmost 12 are discarded or filled with zeroes, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.</p>
<h2 id="gas-cost">Gas Cost</h2>
<p>The general gas cost function, <span class="math inline"><em>C</em></span>, is defined as:</p>
<p><br /><span class="math display">$$C(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \equiv C_{\mathrm{mem}}(\boldsymbol{\mu}'_{\mathrm{i}})-C_{\mathrm{mem}}(\boldsymbol{\mu}_{\mathrm{i}}) + \begin{cases}
C_\text{\tiny SSTORE}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) &amp; \text{if} \quad w = \text{\small SSTORE} \\
G_{\mathrm{exp}} &amp; \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_{\mathbf{s}}[1] = 0 \\
G_{\mathrm{exp}} + G_{\mathrm{expbyte}}\times(1+\lfloor\log_{256}(\boldsymbol{\mu}_{\mathbf{s}}[1])\rfloor) &amp; \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_{\mathbf{s}}[1] &gt; 0 \\
G_{\mathrm{verylow}} + G_{\mathrm{copy}}\times\lceil\boldsymbol{\mu}_{\mathbf{s}}[2] \div 32\rceil &amp; \text{if} \quad w \in W_{\mathrm{copy}} \\

C_{\mathrm{aaccess}}(\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}, A) + G_{\mathrm{copy}}\times\lceil\boldsymbol{\mu}_{\mathbf{s}}[3] \div 32\rceil &amp; \text{if} \quad w = \text{\small EXTCODECOPY} \\
C_{\mathrm{aaccess}}(\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}, A) &amp; \text{if} \quad w \in W_{\mathrm{extaccount}}\\
G_{\mathrm{log}}+G_{\mathrm{logdata}}\times\boldsymbol{\mu}_{\mathbf{s}}[1] &amp; \text{if} \quad w = \text{\small LOG0} \\
G_{\mathrm{log}}+G_{\mathrm{logdata}}\times\boldsymbol{\mu}_{\mathbf{s}}[1]+G_{\mathrm{logtopic}} &amp; \text{if} \quad w = \text{\small LOG1} \\
G_{\mathrm{log}}+G_{\mathrm{logdata}}\times\boldsymbol{\mu}_{\mathbf{s}}[1]+2G_{\mathrm{logtopic}} &amp; \text{if} \quad w = \text{\small LOG2} \\
G_{\mathrm{log}}+G_{\mathrm{logdata}}\times\boldsymbol{\mu}_{\mathbf{s}}[1]+3G_{\mathrm{logtopic}} &amp; \text{if} \quad w = \text{\small LOG3} \\
G_{\mathrm{log}}+G_{\mathrm{logdata}}\times\boldsymbol{\mu}_{\mathbf{s}}[1]+4G_{\mathrm{logtopic}} &amp; \text{if} \quad w = \text{\small LOG4} \\
C_\text{\tiny CALL}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) &amp; \text{if} \quad w \in W_{\mathrm{call}} \\
C_\text{\tiny SELFDESTRUCT}(\boldsymbol{\sigma}, \boldsymbol{\mu}) &amp; \text{if} \quad w = \text{\small SELFDESTRUCT} \\
G_{\mathrm{create}} &amp; \text{if} \quad w = \text{\small CREATE}\\
G_{\mathrm{create}}+G_{\mathrm{keccak256word}} \times \lceil \boldsymbol{\mu}_{\mathbf{s}}[2] \div 32 \rceil &amp; \text{if} \quad w = \text{\small \hyperlink{create2}{CREATE2}}\\
G_{\mathrm{keccak256}}+G_{\mathrm{keccak256word}} \times \lceil \boldsymbol{\mu}_{\mathbf{s}}[1] \div 32 \rceil &amp; \text{if} \quad w = \text{\small KECCAK256}\\
G_{\mathrm{jumpdest}} &amp; \text{if} \quad w = \text{\small JUMPDEST}\\
C_\text{\tiny SLOAD}(\boldsymbol{\mu}, A, I) &amp; \text{if} \quad w = \text{\small SLOAD}\\
G_{\mathrm{zero}} &amp; \text{if} \quad w \in W_{\mathrm{zero}}\\
G_{\mathrm{base}} &amp; \text{if} \quad w \in W_{\mathrm{base}}\\
G_{\mathrm{verylow}} &amp; \text{if} \quad w \in W_{\mathrm{verylow}}\\
G_{\mathrm{low}} &amp; \text{if} \quad w \in W_{\mathrm{low}}\\
G_{\mathrm{mid}} &amp; \text{if} \quad w \in W_{\mathrm{mid}}\\
G_{\mathrm{high}} &amp; \text{if} \quad w \in W_{\mathrm{high}}\\
G_{\mathrm{blockhash}} &amp; \text{if} \quad w = \text{\small \hyperlink{blockhash}{BLOCKHASH}}\\
\end{cases}$$</span><br /> <br /><span class="math display">$$w \equiv \begin{cases} I_{\mathbf{b}}[\boldsymbol{\mu}_{\mathrm{pc}}] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathrm{pc}} &lt; \lVert I_{\mathbf{b}} \rVert\\
\text{\small STOP} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>where: <br /><span class="math display">$$C_{\mathrm{mem}}(a) \equiv G_{\mathrm{memory}} \cdot a + \left\lfloor \dfrac{a^2}{512} \right\rfloor$$</span><br /> <br /><span class="math display">$$\Hy@raisedlink{\hypertarget{C_aaccess}{}}{}C_{\mathrm{aaccess}}(x, A) \equiv
\begin{cases}
G_{\mathrm{warmaccess}}        &amp; \text{if} \quad x \in \hyperlink{accessed_addresses_defn_words_A__a}{A_{\mathbf{a}}}\\
G_{\mathrm{coldaccountaccess}} &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>with <span class="math inline">$C_\text{\tiny CALL}$</span>, <span class="math inline">$C_\text{\tiny SELFDESTRUCT}$</span>, <span class="math inline">$C_\text{\tiny SLOAD}$</span> and <span class="math inline">$C_\text{\tiny SSTORE}$</span> as specified in the appropriate section below. We define the following subsets of instructions:</p>
<p><span class="math inline"><em>W</em><sub><em>z</em><em>e</em><em>r</em><em>o</em></sub></span> = {<span>STOP</span>, <span>RETURN</span>, <span>REVERT</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>b</em><em>a</em><em>s</em><em>e</em></sub></span> = {<span>ADDRESS</span>, <span>ORIGIN</span>, <span>CALLER</span>, <span>CALLVALUE</span>, <span>CALLDATASIZE</span>, <span>CODESIZE</span>, <span>GASPRICE</span>, <span>COINBASE</span>, <span>TIMESTAMP</span>, <span>NUMBER</span>, <span>DIFFICULTY</span>, <span>GASLIMIT</span>, <span>CHAINID</span>, <span>RETURNDATASIZE</span>, <span>POP</span>, <span>PC</span>, <span>MSIZE</span>, <span>GAS</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>v</em><em>e</em><em>r</em><em>y</em><em>l</em><em>o</em><em>w</em></sub></span> = {<span>ADD</span>, <span>SUB</span>, <span>NOT</span>, <span>LT</span>, <span>GT</span>, <span>SLT</span>, <span>SGT</span>, <span>EQ</span>, <span>ISZERO</span>, <span>AND</span>, <span>OR</span>, <span>XOR</span>, <span>BYTE</span>, <span>SHL</span>, <span>SHR</span>, <span>SAR</span>, <span>CALLDATALOAD</span>, <span>MLOAD</span>, <span>MSTORE</span>, <span>MSTORE8</span>, <span>PUSH*</span>, <span>DUP*</span>, <span>SWAP*</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>l</em><em>o</em><em>w</em></sub></span> = {<span>MUL</span>, <span>DIV</span>, <span>SDIV</span>, <span>MOD</span>, <span>SMOD</span>, <span>SIGNEXTEND</span>, <span>SELFBALANCE</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>m</em><em>i</em><em>d</em></sub></span> = {<span>ADDMOD</span>, <span>MULMOD</span>, <span>JUMP</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>h</em><em>i</em><em>g</em><em>h</em></sub></span> = {<span>JUMPI</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>c</em><em>o</em><em>p</em><em>y</em></sub></span> = {<span>CALLDATACOPY</span>, <span>CODECOPY</span>, <span>RETURNDATACOPY</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>c</em><em>a</em><em>l</em><em>l</em></sub></span> = {<span>CALL</span>, <span>CALLCODE</span>, <span>DELEGATECALL</span>, <span>STATICCALL</span>}</p>
<p><span class="math inline"><em>W</em><sub><em>e</em><em>x</em><em>t</em><em>a</em><em>c</em><em>c</em><em>o</em><em>u</em><em>n</em><em>t</em></sub></span> = {<span>BALANCE</span>, <span>EXTCODESIZE</span>, <span>EXTCODEHASH</span>}</p>
<p>Note the memory cost component, given as the product of <span class="math inline"><em>G</em><sub><em>m</em><em>e</em><em>m</em><em>o</em><em>r</em><em>y</em></sub></span> and the maximum of 0 &amp; the ceiling of the number of words in size that the memory must be over the current number of words, <span class="math inline"><strong>μ</strong><sub><em>i</em></sub></span> in order that all accesses reference valid memory whether for read or write. Such accesses must be for non-zero number of bytes.</p>
<p>Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory to be extended to the beginning of the range. <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub></span> is defined as this new maximum number of words of active memory; special-cases are given where these two are not equal.</p>
<p>Note also that <span class="math inline"><em>C</em><sub><em>m</em><em>e</em><em>m</em></sub></span> is the memory cost function (the expansion function being the difference between the cost before and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 704B of memory used, after which it costs substantially more.</p>
<p>While defining the instruction set, we defined the memory-expansion for range function, <span class="math inline"><em>M</em></span>, thus:</p>
<p><br /><span class="math display">$$M(s, f, l) \equiv \begin{cases}
s &amp; \text{if} \quad l = 0 \\
\max(s, \ceil{ (f + l) \div 32 }) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<p>Another useful function is “all but one 64th” function <span class="math inline"><em>L</em></span> defined as:</p>
<p><br /><span class="math display">$$\Hy@raisedlink{\hypertarget{L_but_64}{}}{}
L(n) \equiv n - \lfloor n / 64 \rfloor$$</span><br /></p>
<h2 id="subsec:instruction-set">Instruction Set</h2>
<p>As previously specified in section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>, these definitions take place in the final context there. In particular we assume <span class="math inline"><em>O</em></span> is the EVM state-progression function and define the terms pertaining to the next cycle’s state <span class="math inline">(<strong>σ</strong>′, <strong>μ</strong>′)</span> such that: <br /><span class="math display"><em>O</em>(<strong>σ</strong>, <strong>μ</strong>, <em>A</em>, <em>I</em>) ≡ (<strong>σ</strong>′, <strong>μ</strong>′, <em>A</em>′, <em>I</em>)  with exceptions, as noted</span><br /></p>
<p>Here given are the various exceptions to the state transition rules given in section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a> specified for each instruction, together with the additional instruction-specific definitions of <span class="math inline"><em>J</em></span> and <span class="math inline"><em>C</em></span>. For each instruction, also specified is <span class="math inline"><em>α</em></span>, the additional items placed on the stack and <span class="math inline"><em>δ</em></span>, the items removed from stack, as defined in section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>.</p>
<p><span>r l r r l</span><br />
<br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x00 &amp; <span>STOP</span> &amp; 0 &amp; 0 &amp; Halts execution.<br />
0x01 &amp; <span>ADD</span> &amp; 2 &amp; 1 &amp; Addition operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0] + <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
0x02 &amp; <span>MUL</span> &amp; 2 &amp; 1 &amp; Multiplication operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0] × <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
0x03 &amp; <span>SUB</span> &amp; 2 &amp; 1 &amp; Subtraction operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0] − <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
0x04 &amp; <span>DIV</span> &amp; 2 &amp; 1 &amp; Integer division operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] = 0\\ \lfloor\boldsymbol{\mu}_{\mathbf{s}}[0] \div \boldsymbol{\mu}_{\mathbf{s}}[1]\rfloor &amp; \text{otherwise}\end{cases}$</span><br />
0x05 &amp; <span>SDIV</span> &amp; 2 &amp; 1 &amp; Signed integer division operation (truncated).<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] = 0\\ -2^{255} &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] = -2^{255} \wedge \, \boldsymbol{\mu}_{\mathbf{s}}[1] = -1\\ \mathbf{sgn} (\boldsymbol{\mu}_{\mathbf{s}}[0] \div \boldsymbol{\mu}_{\mathbf{s}}[1]) \lfloor |\boldsymbol{\mu}_{\mathbf{s}}[0] \div \boldsymbol{\mu}_{\mathbf{s}}[1]| \rfloor &amp; \text{otherwise}\end{cases}$</span><br />
&amp;&amp;&amp;&amp; Where all values are treated as two’s complement signed 256-bit integers.<br />
&amp;&amp;&amp;&amp; Note the overflow semantic when <span class="math inline"> − 2<sup>255</sup></span> is negated.<br />
0x06 &amp; <span>MOD</span> &amp; 2 &amp; 1 &amp; Modulo remainder operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] = 0\\ \boldsymbol{\mu}_{\mathbf{s}}[0] \bmod \boldsymbol{\mu}_{\mathbf{s}}[1] &amp; \text{otherwise}\end{cases}$</span><br />
0x07 &amp; <span>SMOD</span> &amp; 2 &amp; 1 &amp; Signed modulo remainder operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] = 0\\ \mathbf{sgn} (\boldsymbol{\mu}_{\mathbf{s}}[0]) (|\boldsymbol{\mu}_{\mathbf{s}}[0]| \bmod |\boldsymbol{\mu}_{\mathbf{s}}[1]|) &amp; \text{otherwise}\end{cases}$</span><br />
&amp;&amp;&amp;&amp; Where all values are treated as two’s complement signed 256-bit integers.<br />
0x08 &amp; <span>ADDMOD</span> &amp; 3 &amp; 1 &amp; Modulo addition operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] = 0\\ (\boldsymbol{\mu}_{\mathbf{s}}[0] + \boldsymbol{\mu}_{\mathbf{s}}[1]) \bmod \boldsymbol{\mu}_{\mathbf{s}}[2] &amp; \text{otherwise}\end{cases}$</span><br />
&amp;&amp;&amp;&amp; All intermediate calculations of this operation are not subject to the <span class="math inline">2<sup>256</sup></span><br />
&amp;&amp;&amp;&amp; modulo.<br />
0x09 &amp; <span>MULMOD</span> &amp; 3 &amp; 1 &amp; Modulo multiplication operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}0 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] = 0\\ (\boldsymbol{\mu}_{\mathbf{s}}[0] \times \boldsymbol{\mu}_{\mathbf{s}}[1]) \bmod \boldsymbol{\mu}_{\mathbf{s}}[2] &amp; \text{otherwise}\end{cases}$</span><br />
&amp;&amp;&amp;&amp; All intermediate calculations of this operation are not subject to the <span class="math inline">2<sup>256</sup></span><br />
&amp;&amp;&amp;&amp; modulo.<br />
0x0a &amp; <span>EXP</span> &amp; 2 &amp; 1 &amp; Exponential operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]<sup><strong>μ</strong><sub><strong>s</strong></sub>[1]</sup></span><br />
0x0b &amp; <span>SIGNEXTEND</span> &amp; 2 &amp; 1 &amp; Extend length of two’s complement signed integer.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in [0..255]: \boldsymbol{\mu}'_{\mathbf{s}}[0]_{\mathrm{i}} \equiv \begin{cases} \boldsymbol{\mu}_{\mathbf{s}}[1]_{\mathrm{t}} &amp;\text{if} \quad i \leqslant t \quad \text{where} \; t = 256 - 8(\boldsymbol{\mu}_{\mathbf{s}}[0] + 1) \\ \boldsymbol{\mu}_{\mathbf{s}}[1]_{\mathrm{i}} &amp;\text{otherwise} \end{cases}$</span><br />
<br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x10 &amp; <span>LT</span> &amp; 2 &amp; 1 &amp; Less-than comparison.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] &lt; \boldsymbol{\mu}_{\mathbf{s}}[1] \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
0x11 &amp; <span>GT</span> &amp; 2 &amp; 1 &amp; Greater-than comparison.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] &gt; \boldsymbol{\mu}_{\mathbf{s}}[1] \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
0x12 &amp; <span>SLT</span> &amp; 2 &amp; 1 &amp; Signed less-than comparison.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] &lt; \boldsymbol{\mu}_{\mathbf{s}}[1] \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; Where all values are treated as two’s complement signed 256-bit integers.<br />
0x13 &amp; <span>SGT</span> &amp; 2 &amp; 1 &amp; Signed greater-than comparison.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] &gt; \boldsymbol{\mu}_{\mathbf{s}}[1] \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; Where all values are treated as two’s complement signed 256-bit integers.<br />
0x14 &amp; <span>EQ</span> &amp; 2 &amp; 1 &amp; Equality comparison.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] = \boldsymbol{\mu}_{\mathbf{s}}[1] \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
0x15 &amp; <span>ISZERO</span> &amp; 1 &amp; 1 &amp; Simple not operator.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] = 0 \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
0x16 &amp; <span>AND</span> &amp; 2 &amp; 1 &amp; Bitwise AND operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">∀<em>i</em> ∈ [0..255] : <strong>μ</strong>′<sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ∧ <strong>μ</strong><sub><strong>s</strong></sub>[1]<sub><em>i</em></sub></span><br />
0x17 &amp; <span>OR</span> &amp; 2 &amp; 1 &amp; Bitwise OR operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">∀<em>i</em> ∈ [0..255] : <strong>μ</strong>′<sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ∨ <strong>μ</strong><sub><strong>s</strong></sub>[1]<sub><em>i</em></sub></span><br />
0x18 &amp; <span>XOR</span> &amp; 2 &amp; 1 &amp; Bitwise XOR operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">∀<em>i</em> ∈ [0..255] : <strong>μ</strong>′<sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]<sub><em>i</em></sub> ⊕ <strong>μ</strong><sub><strong>s</strong></sub>[1]<sub><em>i</em></sub></span><br />
0x19 &amp; <span>NOT</span> &amp; 1 &amp; 1 &amp; Bitwise NOT operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in [0..255]: \boldsymbol{\mu}'_{\mathbf{s}}[0]_{\mathrm{i}} \equiv \begin{cases} 1 &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0]_{\mathrm{i}} = 0 \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
0x1a &amp; <span>BYTE</span> &amp; 2 &amp; 1 &amp; Retrieve single byte from word.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in [0..255]: \boldsymbol{\mu}'_{\mathbf{s}}[0]_{\mathrm{i}} \equiv \begin{cases} \boldsymbol{\mu}_{\mathbf{s}}[1]_{(i - 248 + 8\boldsymbol{\mu}_{\mathbf{s}}[0])} &amp; \text{if} \quad i \geq 248 \wedge \boldsymbol{\mu}_{\mathbf{s}}[0] &lt; 32 \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; For the Nth byte, we count from the left (i.e. N=0 would be the most significant<br />
&amp;&amp;&amp;&amp; in big endian).<br />
0x1b &amp; <span>SHL</span> &amp; 2 &amp; 1 &amp; Left shift operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ (<strong>μ</strong><sub><strong>s</strong></sub>[1] × 2<sup><strong>μ</strong><sub><strong>s</strong></sub>[0]</sup>) mod 2<sup>256</sup></span><br />
0x1c &amp; <span>SHR</span> &amp; 2 &amp; 1 &amp; Logical right shift operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ ⌊<strong>μ</strong><sub><strong>s</strong></sub>[1] ÷ 2<sup><strong>μ</strong><sub><strong>s</strong></sub>[0]</sup>⌋</span><br />
0x1d &amp; <span>SAR</span> &amp; 2 &amp; 1 &amp; Arithmetic (signed) right shift operation.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ ⌊<strong>μ</strong><sub><strong>s</strong></sub>[1] ÷ 2<sup><strong>μ</strong><sub><strong>s</strong></sub>[0]</sup>⌋</span><br />
&amp;&amp;&amp;&amp; Where <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0]</span> and <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[1]</span> are treated as two’s complement signed 256-bit integers,<br />
&amp;&amp;&amp;&amp; while <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[0]</span> is treated as unsigned.<br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x20 &amp; <span>KECCAK256</span> &amp; 2 &amp; 1 &amp; Compute Keccak-256 hash.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <code>K</code><code>E</code><code>C</code>(<strong>μ</strong><sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]…(<strong>μ</strong><sub><strong>s</strong></sub>[0] + <strong>μ</strong><sub><strong>s</strong></sub>[1] − 1)])</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[1])</span><br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x30 &amp; <span>ADDRESS</span> &amp; 0 &amp; 1 &amp; Get address of currently executing account.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>a</em></sub></span><br />
0x31 &amp; <span>BALANCE</span> &amp; 1 &amp; 1 &amp; Get balance of the given account.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv \begin{cases}\boldsymbol{\sigma}[\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}]_{\mathrm{b}}&amp; \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}] \neq \varnothing\\0&amp;\text{otherwise}\end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>a</strong></sub> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>}</span><br />
0x32 &amp; <span>ORIGIN</span> &amp; 0 &amp; 1 &amp; Get execution origination address.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>o</em></sub></span><br />
&amp;&amp;&amp;&amp; This is the sender of original transaction; it is never an account with<br />
&amp;&amp;&amp;&amp; non-empty associated code.<br />
0x33 &amp; <span>CALLER</span> &amp; 0 &amp; 1 &amp; Get caller address.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>s</em></sub></span><br />
&amp;&amp;&amp;&amp; This is the address of the account that is directly responsible for<br />
&amp;&amp;&amp;&amp; this execution.<br />
0x34 &amp; <span>CALLVALUE</span> &amp; 0 &amp; 1 &amp; Get deposited value by the instruction/transaction responsible for<br />
&amp;&amp;&amp;&amp; this execution.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>v</em></sub></span><br />
0x35 &amp; <span>CALLDATALOAD</span> &amp; 1 &amp; 1 &amp; Get input data of current environment.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><strong>d</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]…(<strong>μ</strong><sub><strong>s</strong></sub>[0] + 31)]  with  <em>I</em><sub><strong>d</strong></sub>[<em>x</em>] = 0  if  <em>x</em> ≥ ∥<em>I</em><sub><strong>d</strong></sub>∥</span><br />
&amp;&amp;&amp;&amp; This pertains to the input data passed with the message call<br />
&amp;&amp;&amp;&amp; instruction or transaction.<br />
0x36 &amp; <span>CALLDATASIZE</span> &amp; 0 &amp; 1 &amp; Get size of input data in current<br />
&amp;&amp;&amp;&amp; environment.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ ∥<em>I</em><sub><strong>d</strong></sub>∥</span><br />
&amp;&amp;&amp;&amp; This pertains to the input data passed with the message call<br />
&amp;&amp;&amp;&amp; instruction or transaction.<br />
0x37 &amp; <span>CALLDATACOPY</span> &amp; 3 &amp; 0 &amp; Copy input data in current environment to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in \{ 0 \dots \boldsymbol{\mu}_{\mathbf{s}}[2] - 1\}: \boldsymbol{\mu}'_{\mathbf{m}}[\boldsymbol{\mu}_{\mathbf{s}}[0] + i ] \equiv
\begin{cases} I_{\mathbf{d}}[\boldsymbol{\mu}_{\mathbf{s}}[1] + i] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] + i &lt; \lVert I_{\mathbf{d}} \rVert \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; The additions in <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[1] + <em>i</em></span> are not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[2])</span><br />
&amp;&amp;&amp;&amp; This pertains to the input data passed with the message call instruction<br />
&amp;&amp;&amp;&amp; or transaction.<br />
0x38 &amp; <span>CODESIZE</span> &amp; 0 &amp; 1 &amp; Get size of code running in current environment.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ ∥<em>I</em><sub><strong>b</strong></sub>∥</span><br />
0x39 &amp; <span>CODECOPY</span> &amp; 3 &amp; 0 &amp; Copy code running in current environment to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in \{ 0 \dots \boldsymbol{\mu}_{\mathbf{s}}[2] - 1\}: \boldsymbol{\mu}'_{\mathbf{m}}[\boldsymbol{\mu}_{\mathbf{s}}[0] + i ] \equiv
\begin{cases} I_{\mathbf{b}}[\boldsymbol{\mu}_{\mathbf{s}}[1] + i] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] + i &lt; \lVert I_{\mathbf{b}} \rVert \\ \text{\small STOP} &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[2])</span><br />
&amp;&amp;&amp;&amp; The additions in <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[1] + <em>i</em></span> are not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
0x3a &amp; <span>GASPRICE</span> &amp; 0 &amp; 1 &amp; Get price of gas in current environment.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>p</em></sub></span><br />
&amp;&amp;&amp;&amp; This is gas price specified by the originating transaction.<br />
0x3b &amp; <span>EXTCODESIZE</span> &amp; 1 &amp; 1 &amp; Get size of an account’s code.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv
\begin{cases}
\lVert \mathbf{b} \rVert &amp; \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}] \neq \varnothing \\
0                        &amp; \text{otherwise}
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><code>K</code><code>E</code><code>C</code>(<strong>b</strong>) ≡ <strong>σ</strong>[<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>]<sub><em>c</em></sub></span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>a</strong></sub> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>}</span><br />
0x3c &amp; <span>EXTCODECOPY</span> &amp; 4 &amp; 0 &amp; Copy an account’s code to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in \{ 0 \dots \boldsymbol{\mu}_{\mathbf{s}}[3] - 1\}: \boldsymbol{\mu}'_{\mathbf{m}}[\boldsymbol{\mu}_{\mathbf{s}}[1] + i ] \equiv
\begin{cases} \mathbf{b}[\boldsymbol{\mu}_{\mathbf{s}}[2] + i] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] + i &lt; \lVert \mathbf{b} \rVert \\ \text{\small STOP} &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><code>K</code><code>E</code><code>C</code>(<strong>b</strong>) ≡ <strong>σ</strong>[<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>]<sub><em>c</em></sub></span><br />
&amp;&amp;&amp;&amp; We assume <span class="math inline"><strong>b</strong> ≡ ()</span> if <span class="math inline"><strong>σ</strong>[<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>] = ⌀</span>.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[1], <strong>μ</strong><sub><strong>s</strong></sub>[3])</span><br />
&amp;&amp;&amp;&amp; The additions in <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2] + <em>i</em></span> are not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>a</strong></sub> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>}</span><br />
</p>
<p>0x3d &amp; <span>RETURNDATASIZE</span> &amp; 0 &amp; 1 &amp; Get size of output data from the previous call from the current<br />
&amp;&amp;&amp;&amp; environment.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ ∥<strong>μ</strong><sub><strong>o</strong></sub>∥</span><br />
0x3e &amp; <span>RETURNDATACOPY</span> &amp; 3 &amp; 0 &amp; Copy output data from the previous call to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\forall i \in \{ 0 \dots \boldsymbol{\mu}_{\mathbf{s}}[2] - 1\}: \boldsymbol{\mu}'_{\mathbf{m}}[\boldsymbol{\mu}_{\mathbf{s}}[0] + i ] \equiv
\begin{cases} \boldsymbol{\mu}_{\mathbf{o}}[\boldsymbol{\mu}_{\mathbf{s}}[1] + i] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] + i &lt; \lVert \boldsymbol{\mu}_{\mathbf{o}} \rVert \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; The additions in <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[1] + <em>i</em></span> are not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[2])</span><br />
0x3f &amp; <span>EXTCODEHASH</span> &amp; 1 &amp; 1 &amp; Get hash of an account’s code.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{s}}[0] \equiv
\begin{cases} 0 &amp; \text{if} \quad \mathtt{DEAD}(\boldsymbol{\sigma}, \boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}) \\ \boldsymbol{\sigma}[\boldsymbol{\mu}_{\mathbf{s}}[0] \bmod 2^{160}]_{\mathrm{c}} &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>a</strong></sub> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup>}</span><br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x40 &amp; <span>BLOCKHASH</span> &amp; 1 &amp; 1 &amp; Get the hash of one of the 256 most recent complete blocks.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>P</em>(<em>I</em><sub><em>H</em><sub><em>p</em></sub></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], 0)</span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><em>P</em></span> is the hash of a block of a particular number, up to a maximum<br />
&amp;&amp;&amp;&amp; age. 0 is left on the stack if the looked for block number is greater than or<br />
&amp;&amp;&amp;&amp; equal to the current block number or more than 256 blocks behind the current block.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$P(h, n, a) \equiv \begin{cases} 0 &amp; \text{if} \quad n &gt; H_{\mathrm{i}} \vee a = 256 \vee h = 0 \\ h &amp; \text{if} \quad n = H_{\mathrm{i}} \\ P(H_{\mathrm{p}}, n, a + 1) &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; and we assert the header <span class="math inline"><em>H</em></span> can be determined from its hash <span class="math inline"><em>h</em></span> unless <span class="math inline"><em>h</em></span> is zero<br />
&amp;&amp;&amp;&amp; (as is the case for the parent hash of the genesis block).<br />
0x41 &amp; <span>COINBASE</span> &amp; 0 &amp; 1 &amp; Get the current block’s beneficiary address.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>H</em></sub><sub><em>c</em></sub></span><br />
0x42 &amp; <span>TIMESTAMP</span> &amp; 0 &amp; 1 &amp; Get the current block’s timestamp.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>H</em></sub><sub><em>s</em></sub></span><br />
0x43 &amp; <span>NUMBER</span> &amp; 0 &amp; 1 &amp; Get the current block’s number.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>H</em></sub><sub><em>i</em></sub></span><br />
0x44 &amp; <span>DIFFICULTY</span> &amp; 0 &amp; 1 &amp; Get the current block’s difficulty.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>H</em></sub><sub><em>d</em></sub></span><br />
0x45 &amp; <span>GASLIMIT</span> &amp; 0 &amp; 1 &amp; Get the current block’s gas limit.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>I</em><sub><em>H</em></sub><sub><em>l</em></sub></span><br />
0x46 &amp; <span>CHAINID</span> &amp; 0 &amp; 1 &amp; Get the <a href="#chain_id">chain ID</a>.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>β</em></span><br />
0x47 &amp; <span>SELFBALANCE</span> &amp; 0 &amp; 1 &amp; Get balance of currently executing account.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><em>b</em></sub></span><br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x50 &amp; <span>POP</span> &amp; 1 &amp; 0 &amp; Remove item from stack.<br />
0x51 &amp; <span>MLOAD</span> &amp; 1 &amp; 1 &amp; Load word from memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]…(<strong>μ</strong><sub><strong>s</strong></sub>[0] + 31)]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathrm{i}} \equiv \max(\boldsymbol{\mu}_{\mathrm{i}}, \ceil{ (\boldsymbol{\mu}_{\mathbf{s}}[0] + 32) \div 32 })$</span><br />
&amp;&amp;&amp;&amp; The addition in the calculation of <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub></span> is not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
0x52 &amp; <span>MSTORE</span> &amp; 2 &amp; 0 &amp; Save word to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]…(<strong>μ</strong><sub><strong>s</strong></sub>[0] + 31)] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathrm{i}} \equiv \max(\boldsymbol{\mu}_{\mathrm{i}}, \ceil{ (\boldsymbol{\mu}_{\mathbf{s}}[0] + 32) \div 32 })$</span><br />
&amp;&amp;&amp;&amp; The addition in the calculation of <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub></span> is not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
0x53 &amp; <span>MSTORE8</span> &amp; 2 &amp; 0 &amp; Save byte to memory.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]] ≡ (<strong>μ</strong><sub><strong>s</strong></sub>[1] mod 256)</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathrm{i}} \equiv \max(\boldsymbol{\mu}_{\mathrm{i}}, \ceil{ (\boldsymbol{\mu}_{\mathbf{s}}[0] + 1) \div 32 })$</span><br />
&amp;&amp;&amp;&amp; The addition in the calculation of <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub></span> is not subject to the <span class="math inline">2<sup>256</sup></span> modulo.<br />
0x54 &amp; <span>SLOAD</span> &amp; 1 &amp; 1 &amp; Load word from storage.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><strong>s</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>K</strong></sub> ≡ <em>A</em><sub><strong>K</strong></sub> ∪ {(<em>I</em><sub><em>a</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0])}</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny SLOAD}}(\boldsymbol{\mu}, A, I) \equiv
\begin{cases}
G_{\mathrm{warmaccess}} &amp; \text{if} \quad (I_{\mathrm{a}}, \boldsymbol{\mu}_{\mathbf{s}}[0]) \in A_{\mathbf{K}} \\
G_{\mathrm{coldsload}}  &amp; \text{otherwise}
\end{cases}$</span><br />
0x55 &amp; <span>SSTORE</span> &amp; 2 &amp; 0 &amp; Save word to storage.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>σ</strong>′[<em>I</em><sub><em>a</em></sub>]<sub><strong>s</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>K</strong></sub> ≡ <em>A</em><sub><strong>K</strong></sub> ∪ {(<em>I</em><sub><em>a</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0])}</span><br />
&amp;&amp;&amp;&amp;<span class="math inline">$C_{\text{\tiny SSTORE}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$</span> and <span class="math inline"><em>A</em>′<sub><em>r</em></sub></span> are specified by EIP-2200 as follows.<br />
&amp;&amp;&amp;&amp; We remind the reader that the checkpoint (“original”) state <span class="math inline">$\hyperlink{sigma_0}{\boldsymbol{\sigma}_0}$</span> is the state<br />
&amp;&amp;&amp;&amp; if the current transaction were to revert.<br />
&amp;&amp;&amp;&amp; Let <span class="math inline"><em>v</em><sub>0</sub> = <strong>σ</strong><sub>0</sub>[<em>I</em><sub><em>a</em></sub>]<sub><strong>s</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]]</span> be the original value of the storage slot.<br />
&amp;&amp;&amp;&amp; Let <span class="math inline"><em>v</em> = <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><strong>s</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[0]]</span> be the current value.<br />
&amp;&amp;&amp;&amp; Let <span class="math inline"><em>v</em>′ = <strong>μ</strong><sub><strong>s</strong></sub>[1]</span> be the new value.<br />
&amp;&amp;&amp;&amp; Then:<br />
&amp;&amp;&amp;&amp; <span class="math inline">$\!\begin{aligned}
C_{\text{\tiny SSTORE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) &amp;\equiv
\begin{cases}
0                      &amp; \text{if} \quad (I_{\mathrm{a}}, \boldsymbol{\mu}_{\mathbf{s}}[0]) \in A_{\mathbf{K}} \\
G_{\mathrm{coldsload}} &amp; \text{otherwise} \\
\end{cases} \\
&amp;+
\begin{cases}
G_{\mathrm{warmaccess}}  &amp; \text{if} \quad v = v' \; \vee \; v_0 \neq v \\
G_{\mathrm{sset}}   &amp; \text{if} \quad v \neq v' \; \wedge \; v_0 = v \; \wedge \; v_0 = 0 \\
G_{\mathrm{sreset}} &amp; \text{if} \quad v \neq v' \; \wedge \; v_0 = v \; \wedge \; v_0 \neq 0 \\
\end{cases}
\end{aligned}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$A'_{\mathrm{r}} \equiv A_{\mathrm{r}} + \begin{cases}
R_{\mathrm{sclear}} &amp; \text{if} \quad v \neq v' \; \wedge \; v_0 = v \; \wedge \; v' = 0 \\
r_{\text{dirtyclear}} + r_{\text{dirtyreset}} &amp; \text{if} \quad v \neq v' \; \wedge \; v_0 \neq v \\
0 &amp; \text{otherwise} \\
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; where<br />
&amp;&amp;&amp;&amp;<span class="math inline">$r_{\text{dirtyclear}} \equiv \begin{cases}
-R_{\mathrm{sclear}} &amp; \text{if} \quad v_0 \neq 0 \; \wedge \; v = 0 \\
R_{\mathrm{sclear}} &amp; \text{if} \quad v_0 \neq 0 \; \wedge \; v' = 0 \\
0 &amp; \text{otherwise} \\
\end{cases}$</span><br />
&amp;&amp;&amp;&amp;<span class="math inline">$r_{\text{dirtyreset}} \equiv \begin{cases}
G_{\mathrm{sset}} - G_{\mathrm{warmaccess}}   &amp; \text{if} \quad v_0 = v' \; \wedge \; v_0 = 0 \\
G_{\mathrm{sreset}} - G_{\mathrm{warmaccess}} &amp; \text{if} \quad v_0 = v' \; \wedge \; v_0 \neq 0 \\
0 &amp; \text{otherwise} \\
\end{cases}$</span><br />
0x56 &amp; <span>JUMP</span> &amp; 1 &amp; 0 &amp; Alter the program counter.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$J_{\text{\tiny JUMP}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_{\mathbf{s}}[0]$</span><br />
&amp;&amp;&amp;&amp; This has the effect of writing said value to <span class="math inline"><strong>μ</strong><sub><em>p</em><em>c</em></sub></span>. See section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>.<br />
0x57 &amp; <span>JUMPI</span> &amp; 2 &amp; 0 &amp; Conditionally alter the program counter.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$J_{\text{\tiny JUMPI}}(\boldsymbol{\mu}) \equiv \begin{cases} \boldsymbol{\mu}_{\mathbf{s}}[0] &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[1] \neq 0 \\ \boldsymbol{\mu}_{\mathrm{pc}} + 1 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; This has the effect of writing said value to <span class="math inline"><strong>μ</strong><sub><em>p</em><em>c</em></sub></span>. See section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>.<br />
0x58 &amp; <span>PC</span> &amp; 0 &amp; 1 &amp; Get the value of the program counter <em>prior</em> to the increment<br />
&amp;&amp;&amp;&amp; corresponding to this instruction.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><em>p</em><em>c</em></sub></span><br />
</p>
<p>0x59 &amp; <span>MSIZE</span> &amp; 0 &amp; 1 &amp; Get the size of active memory in bytes.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ 32<strong>μ</strong><sub><em>i</em></sub></span><br />
0x5a &amp; <span>GAS</span> &amp; 0 &amp; 1 &amp; Get the amount of available gas, including the corresponding reduction<br />
&amp;&amp;&amp;&amp; for the cost of this instruction.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><em>g</em></sub></span><br />
0x5b &amp; <span>JUMPDEST</span> &amp; 0 &amp; 0 &amp; Mark a valid destination for jumps.<br />
&amp;&amp;&amp;&amp; This operation has no effect on machine state during execution.<br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x60 &amp; <span>PUSH1</span> &amp; 0 &amp; 1 &amp; Place 1 byte item on stack.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>c</em>(<strong>μ</strong><sub><em>p</em><em>c</em></sub> + 1)</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\text{where} \quad c(x) \equiv \begin{cases} I_{\mathbf{b}}[x] &amp; \text{if} \quad x &lt; \lVert I_{\mathbf{b}} \rVert \\ 0 &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; The bytes are read in line from the program code’s bytes array.<br />
&amp;&amp;&amp;&amp; The function <span class="math inline"><em>c</em></span> ensures the bytes default to zero if they extend past the limits.<br />
&amp;&amp;&amp;&amp; The byte is right-aligned (takes the lowest significant place in big endian).<br />
0x61 &amp; <span>PUSH2</span> &amp; 0 &amp; 1 &amp; Place 2-byte item on stack.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>c</strong>((<strong>μ</strong><sub><em>p</em><em>c</em></sub> + 1)…(<strong>μ</strong><sub><em>p</em><em>c</em></sub> + 2))</span><br />
&amp;&amp;&amp;&amp; with <span class="math inline"><strong>c</strong>(<strong>x</strong>) ≡ (<em>c</em>(<strong>x</strong><sub>0</sub>), ..., <em>c</em>(<strong>x</strong><sub>∥<em>x</em>∥ − 1</sub>))</span> with <span class="math inline"><em>c</em></span> as defined as above.<br />
&amp;&amp;&amp;&amp; The bytes are right-aligned (takes the lowest significant place in big endian).<br />
&amp; &amp; ⋮&amp; ⋮&amp;<br />
0x7f &amp; <span>PUSH32</span> &amp; 0 &amp; 1 &amp; Place 32-byte (full word) item on stack.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>c</strong>((<strong>μ</strong><sub><em>p</em><em>c</em></sub> + 1)…(<strong>μ</strong><sub><em>p</em><em>c</em></sub> + 32))</span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><strong>c</strong></span> is defined as above.<br />
&amp;&amp;&amp;&amp; The bytes are right-aligned (takes the lowest significant place in big endian).<br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x80 &amp; <span>DUP1</span> &amp; 1 &amp; 2 &amp; Duplicate 1st stack item.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]</span><br />
0x81 &amp; <span>DUP2</span> &amp; 2 &amp; 3 &amp; Duplicate 2nd stack item.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
&amp; &amp; ⋮&amp; ⋮&amp;<br />
0x8f &amp; <span>DUP16</span> &amp; 16 &amp; 17 &amp; Duplicate 16th stack item.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[15]</span><br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0x90 &amp; <span>SWAP1</span> &amp; 2 &amp; 2 &amp; Exchange 1st and 2nd stack items.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[1]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[1] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]</span><br />
0x91 &amp; <span>SWAP2</span> &amp; 3 &amp; 3 &amp; Exchange 1st and 3rd stack items.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[2]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[2] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]</span><br />
&amp; &amp; ⋮&amp; ⋮&amp;<br />
0x9f &amp; <span>SWAP16</span> &amp; 17 &amp; 17 &amp; Exchange 1st and 17th stack items.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[16]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[16] ≡ <strong>μ</strong><sub><strong>s</strong></sub>[0]</span><br />
</p>
<p><br />
<br />
<br />
<br />
<br />
<br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0xa0 &amp; <span>LOG0</span> &amp; 2 &amp; 0 &amp; Append log record with no topics.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>t</strong> ≡ ()</span><br />
0xa1 &amp; <span>LOG1</span> &amp; 3 &amp; 0 &amp; Append log record with one topic.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>t</strong> ≡ (<strong>μ</strong><sub><strong>s</strong></sub>[2])</span><br />
&amp; &amp; ⋮&amp; ⋮&amp;<br />
0xa4 &amp; <span>LOG4</span> &amp; 6 &amp; 0 &amp; Append log record with four topics.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>t</strong> ≡ (<strong>μ</strong><sub><strong>s</strong></sub>[2], <strong>μ</strong><sub><strong>s</strong></sub>[3], <strong>μ</strong><sub><strong>s</strong></sub>[4], <strong>μ</strong><sub><strong>s</strong></sub>[5])</span><br />
</p>
<p><br />
<strong>Value</strong> &amp; <strong>Mnemonic</strong> &amp; <span class="math inline"><em>δ</em></span> &amp; <span class="math inline"><em>α</em></span> &amp; <strong>Description</strong><br />
0xf0 &amp; <span>CREATE</span> &amp; 3 &amp; 1 &amp; Create a new account with associated code.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>i</strong> ≡ <strong>μ</strong><sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[1]…(<strong>μ</strong><sub><strong>s</strong></sub>[1] + <strong>μ</strong><sub><strong>s</strong></sub>[2] − 1)]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\hyperlink{salt}{\zeta} \equiv \varnothing$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$(\boldsymbol{\sigma}', g', A', z, \mathbf{o}) \equiv \begin{cases}
\hyperlink{lambda}{\Lambda}(\boldsymbol{\sigma}^*, A, I_{\mathrm{a}}, I_{\mathrm{o}}, L(\boldsymbol{\mu}_{\mathrm{g}}), I_{\mathrm{p}}, \boldsymbol{\mu}_{\mathbf{s}}[0], \mathbf{i}, I_{\mathrm{e}} + 1, \zeta, I_{\mathrm{w}}) &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[0] \leqslant \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}} \; \\ \quad &amp;\wedge\; I_{\mathrm{e}} &lt; 1024\\
\big(\boldsymbol{\sigma}, L(\boldsymbol{\mu}_{\mathrm{g}}), A, 0, () \big) &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>σ</strong><sup>*</sup> ≡ <strong>σ</strong>  except  <strong>σ</strong><sup>*</sup>[<em>I</em><sub><em>a</em></sub>]<sub><em>n</em></sub> = <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><em>n</em></sub> + 1</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathrm{g}} \equiv \boldsymbol{\mu}_{\mathrm{g}} - \hyperlink{L_but_64}{L}(\boldsymbol{\mu}_{\mathrm{g}}) + g'$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>x</em></span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><em>x</em> = 0</span> if <span class="math inline"><em>z</em> = 0</span>, i.e., the <a href="#contract_creation_result">contract creation process failed</a>, or <span class="math inline"><em>I</em><sub><em>e</em></sub> = 1024</span><br />
&amp;&amp;&amp;&amp; (the maximum call depth limit is reached) or <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[0] &gt; <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><em>b</em></sub></span> (balance of the caller<br />
&amp;&amp;&amp;&amp; is too low to fulfil the value transfer); and otherwise <span class="math inline"><em>x</em> = <code>A</code><code>D</code><code>D</code><code>R</code>(<em>I</em><sub><em>a</em></sub>, <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><em>n</em></sub>, <em>ζ</em>, <strong>i</strong>)</span>, the<br />
&amp;&amp;&amp;&amp; address of the newly created account (<a href="#eq:new-address" data-reference-type="ref" data-reference="eq:new-address">[eq:new-address]</a>).<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[1], <strong>μ</strong><sub><strong>s</strong></sub>[2])</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathbf{o}} \equiv \begin{cases}
() &amp; \text{if} \quad z = 1 \\
\mathbf{o} &amp; \text{otherwise}
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; Thus the operand order is: value, input offset, input size.<br />
0xf1 &amp; <span>CALL</span> &amp; 7 &amp; 1 &amp; Message-call into an account.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>i</strong> ≡ <strong>μ</strong><sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[3]…(<strong>μ</strong><sub><strong>s</strong></sub>[3] + <strong>μ</strong><sub><strong>s</strong></sub>[4] − 1)]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$(\boldsymbol{\sigma}', g', A', x, \mathbf{o}) \equiv \begin{cases}
\begin{array}{l}\hyperlink{theta}{\Theta}(\boldsymbol{\sigma}, A^*, I_{\mathrm{a}}, I_{\mathrm{o}}, t, t, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A),\\ \quad I_{\mathrm{p}}, \boldsymbol{\mu}_{\mathbf{s}}[2], \boldsymbol{\mu}_{\mathbf{s}}[2], \mathbf{i}, I_{\mathrm{e}} + 1, I_{\mathrm{w}})\end{array}
  &amp; \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] \leqslant \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}} \;\wedge \\ \quad\quad I_{\mathrm{e}} &lt; 1024\end{array}\\
  (\boldsymbol{\sigma}, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A), A, 0, ()) &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>n</em> ≡ min ({<strong>μ</strong><sub><strong>s</strong></sub>[6], ∥<strong>o</strong>∥})</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>m</strong></sub>[<strong>μ</strong><sub><strong>s</strong></sub>[5]…(<strong>μ</strong><sub><strong>s</strong></sub>[5] + <em>n</em> − 1)] = <strong>o</strong>[0…(<em>n</em> − 1)]</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>o</strong></sub> = <strong>o</strong></span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\mu}'_{\mathrm{g}} \equiv \boldsymbol{\mu}_{\mathrm{g}} - C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A) + g'$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><strong>s</strong></sub>[0] ≡ <em>x</em></span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em><sup>*</sup> ≡ <em>A</em>  except  <em>A</em><sub><strong>a</strong></sub><sup>*</sup> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<em>t</em>}</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>t</em> ≡ <strong>μ</strong><sub><strong>s</strong></sub>[1] mod 2<sup>160</sup></span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[3], <strong>μ</strong><sub><strong>s</strong></sub>[4]), <strong>μ</strong><sub><strong>s</strong></sub>[5], <strong>μ</strong><sub><strong>s</strong></sub>[6])</span><br />
&amp;&amp;&amp;&amp; where <span class="math inline"><em>x</em> = 0</span> if the <a href="#code_execution_result">code execution for this operation failed</a>, or if<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2] &gt; <strong>σ</strong>[<em>I</em><sub><em>a</em></sub>]<sub><em>b</em></sub></span> (not enough funds) or <span class="math inline"><em>I</em><sub><em>e</em></sub> = 1024</span> (call depth limit reached); <span class="math inline"><em>x</em> = 1</span><br />
&amp;&amp;&amp;&amp; otherwise.<br />
&amp;&amp;&amp;&amp; Thus the operand order is: gas, to, value, in offset, in size, out offset, out size.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny CALL}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) \equiv C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) + C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A)$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) \equiv  \begin{cases}
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) + G_{\mathrm{callstipend}} &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] \neq 0 \\
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) &amp; \text{otherwise}
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) \equiv \begin{cases}
\min\{ \hyperlink{L_but_64}{L}(\boldsymbol{\mu}_{\mathrm{g}} - C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A)), \boldsymbol{\mu}_{\mathbf{s}}[0] \} &amp; \text{if} \quad \boldsymbol{\mu}_{\mathrm{g}} \ge C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A)\\
\boldsymbol{\mu}_{\mathbf{s}}[0] &amp; \text{otherwise}
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}, A) \equiv \hyperlink{C_aaccess}{C_{\mathrm{aaccess}}}(t, A) + C_{\text{\tiny XFER}}(\boldsymbol{\mu}) + C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny XFER}}(\boldsymbol{\mu}) \equiv \begin{cases}
G_{\mathrm{callvalue}} &amp; \text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] \neq 0 \\
0 &amp; \text{otherwise}
\end{cases}$</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{\mathrm{newaccount}} &amp; \text{if} \quad \mathtt{DEAD}(\boldsymbol{\sigma}, t) \wedge \boldsymbol{\mu}_{\mathbf{s}}[2] \neq 0 \\
0 &amp; \text{otherwise}
\end{cases}$</span><br />
0xf2 &amp; <span>CALLCODE</span> &amp; 7 &amp; 1 &amp; Message-call into this account with an alternative account’s code.<br />
&amp;&amp;&amp;&amp; Exactly equivalent to <span>CALL</span> except:<br />
&amp;&amp;&amp;&amp; <span class="math inline">$(\boldsymbol{\sigma}', g', A', x, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, A^*, I_{\mathrm{a}}, I_{\mathrm{o}}, I_{\mathrm{a}}, t, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A), \\ \quad I_{\mathrm{p}}, \boldsymbol{\mu}_{\mathbf{s}}[2], \boldsymbol{\mu}_{\mathbf{s}}[2], \mathbf{i}, I_{\mathrm{e}} + 1, I_{\mathrm{w}})\end{array}
  &amp; \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_{\mathbf{s}}[2] \leqslant \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}} \;\wedge\\ \quad\quad{}I_{\mathrm{e}} &lt; 1024\end{array} \\
  (\boldsymbol{\sigma}, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A), A, 0, ()) &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; Note the change in the fourth parameter to the call <span class="math inline">$\hyperlink{theta}{\Theta}$</span> from the 2nd stack value<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[1]</span> (as in <span>CALL</span>) to the present address <span class="math inline"><em>I</em><sub><em>a</em></sub></span>. This means that the recipient is in<br />
&amp;&amp;&amp;&amp; fact the same account as at present, simply that the code is overwritten.<br />
0xf3 &amp; <span>RETURN</span> &amp; 2 &amp; 0 &amp; Halt execution returning output data.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_{\mathbf{m}}[ \boldsymbol{\mu}_{\mathbf{s}}[0] \dots ( \boldsymbol{\mu}_{\mathbf{s}}[0] + \boldsymbol{\mu}_{\mathbf{s}}[1] - 1 ) ]$</span><br />
&amp;&amp;&amp;&amp; This has the effect of halting the execution at this point with output defined.<br />
&amp;&amp;&amp;&amp; See section <a href="#ch:model" data-reference-type="ref" data-reference="ch:model">9</a>.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[1])</span><br />
</p>
<p>0xf4 &amp; <span>DELEGATECALL</span> &amp; 6 &amp; 1 &amp; Message-call into this account with an alternative account’s code, but<br />
&amp;&amp;&amp;&amp; persisting the current values for <span><em>sender</em></span> and <span><em>value</em></span>.<br />
&amp;&amp;&amp;&amp; Compared with <span>CALL</span>, <span>DELEGATECALL</span> takes one fewer arguments. The<br />
&amp;&amp;&amp;&amp; omitted argument is <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2]</span>. As a result, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[3]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[4]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[5]</span> and <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[6]</span> in the<br />
&amp;&amp;&amp;&amp; definition of <span>CALL</span> should respectively be replaced with <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[3]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[4]</span> and<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[5]</span>. Otherwise it is equivalent to <span>CALL</span> except:<br />
&amp;&amp;&amp;&amp; <span class="math inline">$(\boldsymbol{\sigma}', g', A', x, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, A^*, I_{\mathrm{s}}, I_{\mathrm{o}}, I_{\mathrm{a}}, t, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A), \\\quad I_{\mathrm{p}}, 0, I_{\mathrm{v}}, \mathbf{i}, I_{\mathrm{e}} + 1, I_{\mathrm{w}})\end{array}
  &amp; \text{if} \quad I_{\mathrm{e}} &lt; 1024 \\
  (\boldsymbol{\sigma}, C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma},\boldsymbol{\mu},A), A, 0, ()) &amp; \text{otherwise} \end{cases}$</span><br />
&amp;&amp;&amp;&amp; Note the changes (in addition to that of the fourth parameter) to the second<br />
&amp;&amp;&amp;&amp; and ninth parameters to the call <span class="math inline">$\hyperlink{theta}{\Theta}$</span>.<br />
&amp;&amp;&amp;&amp; This means that the recipient is in fact the same account as at present, simply<br />
&amp;&amp;&amp;&amp; that the code is overwritten <span><em>and</em></span> the context is almost entirely identical.<br />
0xf5 &amp; <span>CREATE2</span> &amp; 4 &amp; 1 &amp; Create a new account with associated code.<br />
&amp;&amp;&amp;&amp; Exactly equivalent to <span>CREATE</span> except:<br />
&amp;&amp;&amp;&amp; The salt <span class="math inline"><em>ζ</em> ≡ <strong>μ</strong><sub><strong>s</strong></sub>[3]</span>.<br />
0xfa &amp; <span>STATICCALL</span> &amp; 6 &amp; 1 &amp; Static message-call into an account.<br />
&amp;&amp;&amp;&amp; Exactly equivalent to <span>CALL</span> except:<br />
&amp;&amp;&amp;&amp; The argument <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2]</span> is replaced with <span class="math inline">0</span>.<br />
&amp;&amp;&amp;&amp; The deeper argument <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[3]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[4]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[5]</span> and <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[6]</span> are respectively replaced<br />
&amp;&amp;&amp;&amp; with <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[2]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[3]</span>, <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[4]</span> and <span class="math inline"><strong>μ</strong><sub><strong>s</strong></sub>[5]</span>.<br />
&amp;&amp;&amp;&amp; The last argument of <span class="math inline">$\hyperlink{theta}{\Theta}$</span> is <span class="math inline">⊥</span>.<br />
0xfd &amp; <span>REVERT</span> &amp; 2 &amp; 0 &amp; Halt execution reverting state changes but returning data and remaining gas.<br />
&amp;&amp;&amp;&amp; <span class="math inline">$H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_{\mathbf{m}}[ \boldsymbol{\mu}_{\mathbf{s}}[0] \dots ( \boldsymbol{\mu}_{\mathbf{s}}[0] + \boldsymbol{\mu}_{\mathbf{s}}[1] - 1 ) ]$</span><br />
&amp;&amp;&amp;&amp; The effect of this operation is described in (<a href="#eq:X-def" data-reference-type="ref" data-reference="eq:X-def">[eq:X-def]</a>).<br />
&amp;&amp;&amp;&amp; For the gas calculation, we use the memory expansion function,<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>μ</strong>′<sub><em>i</em></sub> ≡ <em>M</em>(<strong>μ</strong><sub><em>i</em></sub>, <strong>μ</strong><sub><strong>s</strong></sub>[0], <strong>μ</strong><sub><strong>s</strong></sub>[1])</span><br />
0xfe &amp; <span>INVALID</span> &amp; <span class="math inline">⌀</span> &amp; <span class="math inline">⌀</span> &amp; Designated invalid instruction.<br />
0xff &amp; <span>SELFDESTRUCT</span> &amp; 1 &amp; 0 &amp; Halt execution and register account for later deletion.<br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>s</strong></sub> ≡ <em>A</em><sub><strong>s</strong></sub> ∪ {<em>I</em><sub><em>a</em></sub>}</span><br />
&amp;&amp;&amp;&amp; <span class="math inline"><em>A</em>′<sub><strong>a</strong></sub> ≡ <em>A</em><sub><strong>a</strong></sub> ∪ {<em>r</em>}</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\boldsymbol{\sigma}'[r] \equiv \begin{cases}
\varnothing &amp;\text{if}\quad \boldsymbol{\sigma}[r] = \varnothing\ \wedge\ \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}} = 0\\
(\boldsymbol{\sigma}[r]_{\mathrm{n}}, \boldsymbol{\sigma}[r]_{\mathrm{b}} + \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}}, \boldsymbol{\sigma}[r]_{\mathbf{s}}, \boldsymbol{\sigma}[r]_{\mathrm{c}}) &amp; \text{if}\quad r \neq I_{\mathrm{a}} \\
(\boldsymbol{\sigma}[r]_{\mathrm{n}}, 0, \boldsymbol{\sigma}[r]_{\mathbf{s}}, \boldsymbol{\sigma}[r]_{\mathrm{c}}) &amp; \text{otherwise}
\end{cases}$</span><br />
<br />
&amp;&amp;&amp;&amp; where <span class="math inline"><em>r</em> = <strong>μ</strong><sub><strong>s</strong></sub>[0] mod 2<sup>160</sup></span><br />
<br />
&amp;&amp;&amp;&amp; <span class="math inline"><strong>σ</strong>′[<em>I</em><sub><em>a</em></sub>]<sub><em>b</em></sub> = 0</span><br />
&amp;&amp;&amp;&amp; <span class="math inline">$\begin{aligned}
C_{\text{\tiny SELFDESTRUCT}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) &amp;\equiv G_{\mathrm{selfdestruct}} 
+ \begin{cases}
  0 &amp; \text{if}\quad r \in \hyperlink{accessed_addresses_defn_words_A__a}{A_{\mathbf{a}}}\\
  G_{\mathrm{coldaccountaccess}} &amp; \text{otherwise}
\end{cases}\\
&amp;+ \begin{cases}
G_{\mathrm{newaccount}} &amp; \text{if}\quad \mathtt{DEAD}(\boldsymbol{\sigma}, r) \wedge \boldsymbol{\sigma}[I_{\mathrm{a}}]_{\mathrm{b}} \neq 0 \\
0 &amp; \text{otherwise}
\end{cases}
\end{aligned}$</span><br />
</p>
<h1 id="app:genesis">Genesis Block</h1>
<div id="Genesis_Block">

</div>
<p>The genesis block is 15 items, and is specified thus: <br /><span class="math display">((0<sub>256</sub>, <code>K</code><code>E</code><code>C</code>(<code>R</code><code>L</code><code>P</code>(())), 0<sub>160</sub>, <em>s</em><em>t</em><em>a</em><em>t</em><em>e</em><em>R</em><em>o</em><em>o</em><em>t</em>, 0, 0, 0<sub>2048</sub>, 2<sup>34</sup>, 0, 0, 3141592, <em>t</em><em>i</em><em>m</em><em>e</em>, 0, 0<sub>256</sub>, <code>K</code><code>E</code><code>C</code>((42))), (), ())</span><br /></p>
<p>Where <span class="math inline">0<sub>256</sub></span> refers to the parent hash, a 256-bit hash which is all zeroes; <span class="math inline">0<sub>160</sub></span> refers to the beneficiary address, a 160-bit hash which is all zeroes; <span class="math inline">0<sub>2048</sub></span> refers to the log bloom, 2048-bit of all zeros; <span class="math inline">2<sup>34</sup></span> refers to the difficulty; the transaction trie root, receipt trie root, gas used, block number and extradata are both <span class="math inline">0</span>, being equivalent to the empty byte array. The sequences of both ommers and transactions are empty and represented by <span class="math inline">()</span>. <span class="math inline"><code>K</code><code>E</code><code>C</code>((42))</span> refers to the Keccak-256 hash of a byte array of length one whose first and only byte is of value 42, used for the nonce. <span class="math inline"><code>K</code><code>E</code><code>C</code>(<code>R</code><code>L</code><code>P</code>(()))</span> value refers to the hash of the ommer list in RLP, both empty lists.</p>
<p>The proof-of-concept series include a development premine, making the state root hash some value <span class="math inline"><em>s</em><em>t</em><em>a</em><em>t</em><em>e</em><em>R</em><em>o</em><em>o</em><em>t</em></span>. Also <span class="math inline"><em>t</em><em>i</em><em>m</em><em>e</em></span> will be set to the initial timestamp of the genesis block. The latest documentation should be consulted for those values.</p>
<h1 id="app:ethash">Ethash</h1>
<h2 id="definitions">Definitions</h2>
<p>We employ the following definitions:</p>
<p><span>lcl</span> Name &amp; Value &amp; Description<br />
<span class="math inline"><em>J</em><sub><em>w</em><em>o</em><em>r</em><em>d</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> &amp; 4 &amp; Bytes in word.<br />
<span class="math inline"><em>J</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>i</em><em>n</em><em>i</em><em>t</em></sub></span> &amp; <span class="math inline">2<sup>30</sup></span> &amp; Bytes in dataset at genesis.<br />
<span class="math inline"><em>J</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub></span> &amp; <span class="math inline">2<sup>23</sup></span> &amp; Dataset growth per epoch.<br />
<span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>i</em><em>n</em><em>i</em><em>t</em></sub></span> &amp; <span class="math inline">2<sup>24</sup></span> &amp; Bytes in cache at genesis.<br />
<span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub></span> &amp; <span class="math inline">2<sup>17</sup></span> &amp; Cache growth per epoch.<br />
<span class="math inline"><em>J</em><sub><em>e</em><em>p</em><em>o</em><em>c</em><em>h</em></sub></span> &amp; 30000 &amp; Blocks per epoch.<br />
<span class="math inline"><em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> &amp; 128 &amp; mix length in bytes.<br />
<span class="math inline"><em>J</em><sub><em>h</em><em>a</em><em>s</em><em>h</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> &amp; 64 &amp; Hash length in bytes.<br />
<span class="math inline"><em>J</em><sub><em>p</em><em>a</em><em>r</em><em>e</em><em>n</em><em>t</em><em>s</em></sub></span> &amp; 256 &amp; Number of parents of each dataset element.<br />
<span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>r</em><em>o</em><em>u</em><em>n</em><em>d</em><em>s</em></sub></span> &amp; 3 &amp; Number of rounds in cache production.<br />
<span class="math inline"><em>J</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em><em>e</em><em>s</em></sub></span> &amp; 64 &amp; Number of accesses in hashimoto loop.<br />
</p>
<h2 id="size-of-dataset-and-cache">Size of dataset and cache</h2>
<p>The size for Ethash’s cache <span class="math inline"><strong>c</strong> ∈ 𝔹</span> and dataset <span class="math inline"><strong>d</strong> ∈ 𝔹</span> depend on the epoch, which in turn depends on the block number. <br /><span class="math display">$$E_{\mathrm{epoch}}(H_{\mathrm{i}}) = \left\lfloor\frac{H_{\mathrm{i}}}{J_{\mathrm{epoch}}}\right\rfloor$$</span><br /> The size of the dataset growth by <span class="math inline"><em>J</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub></span> bytes, and the size of the cache by <span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub></span> bytes, every epoch. In order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a multiple of <span class="math inline"><em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span>, for the dataset, and <span class="math inline"><em>J</em><sub><em>h</em><em>a</em><em>s</em><em>h</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> for the cache. Let <span class="math inline"><em>d</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub> = ∥<strong>d</strong>∥</span> be the size of the dataset. Which is calculated using <br /><span class="math display"><em>d</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub> = <em>E</em><sub><em>p</em><em>r</em><em>i</em><em>m</em><em>e</em></sub>(<em>J</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>i</em><em>n</em><em>i</em><em>t</em></sub> + <em>J</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub> ⋅ <em>E</em><sub><em>e</em><em>p</em><em>o</em><em>c</em><em>h</em></sub> − <em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub>, <em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub>)</span><br /> The size of the cache, <span class="math inline"><em>c</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub></span>, is calculated using <br /><span class="math display"><em>c</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub> = <em>E</em><sub><em>p</em><em>r</em><em>i</em><em>m</em><em>e</em></sub>(<em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>i</em><em>n</em><em>i</em><em>t</em></sub> + <em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>g</em><em>r</em><em>o</em><em>w</em><em>t</em><em>h</em></sub> ⋅ <em>E</em><sub><em>e</em><em>p</em><em>o</em><em>c</em><em>h</em></sub> − <em>J</em><sub><em>h</em><em>a</em><em>s</em><em>h</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub>, <em>J</em><sub><em>h</em><em>a</em><em>s</em><em>h</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub>)</span><br /> <br /><span class="math display">$$E_{\mathrm{prime}}(x, y) = \begin{cases}
x &amp; \text{if} \quad x / y \in \mathbb{N} \\
E_{\mathrm{prime}}(x - 2 \cdot y, y) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<h2 id="dataset-generation">Dataset generation</h2>
<p>In order to generate the dataset we need the cache <span class="math inline"><strong>c</strong></span>, which is an array of bytes. It depends on the cache size <span class="math inline"><em>c</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub></span> and the seed hash <span class="math inline"><strong>s</strong> ∈ 𝔹<sub>32</sub></span>.</p>
<h3 id="seed-hash">Seed hash</h3>
<p>The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash: <br /><span class="math display"><strong>s</strong> = <em>C</em><sub><em>s</em><em>e</em><em>e</em><em>d</em><em>h</em><em>a</em><em>s</em><em>h</em></sub>(<em>H</em><sub><em>i</em></sub>)</span><br /> <br /><span class="math display">$$C_{\mathrm{seedhash}}(H_{\mathrm{i}}) = \begin{cases}
\mathbf{0}_{32} &amp; \text{if} \quad E_{\mathrm{epoch}}(H_{\mathrm{i}}) = 0 \quad  \\
\texttt{KEC}(C_{\mathrm{seedhash}}(H_{\mathrm{i}} - J_{\mathrm{epoch}})) &amp; \text{otherwise}
\end{cases}$$</span><br /> With <span class="math inline"><strong>0</strong><sub>32</sub></span> being 32 bytes of zeros.</p>
<h3 id="cache">Cache</h3>
<p>The cache production process involves using the seed hash to first sequentially filling up <span class="math inline"><em>c</em><sub><em>s</em><em>i</em><em>z</em><em>e</em></sub></span> bytes of memory, then performing <span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>r</em><em>o</em><em>u</em><em>n</em><em>d</em><em>s</em></sub></span> passes of the RandMemoHash algorithm created by <span class="citation" data-cites="lerner2014randmemohash"></span>. The initial cache <span class="math inline"><strong>c</strong><strong>′</strong></span>, being an array of arrays of single bytes, will be constructed as follows.</p>
<p>We define the array <span class="math inline"><strong>c</strong><sub><em>i</em></sub></span>, consisting of 64 single bytes, as the <span class="math inline"><em>i</em></span>th element of the initial cache: <br /><span class="math display">$$\mathbf{c}_{i} = \begin{cases}
\texttt{KEC512}(\mathbf{s}) &amp; \text{if} \quad i = 0 \quad  \\
\texttt{KEC512}(\mathbf{c}_{i-1}) &amp; \text{otherwise}
\end{cases}$$</span><br /> Therefore <span class="math inline"><strong>c</strong><strong>′</strong></span> can be defined as <br /><span class="math display"><strong>c</strong><strong>′</strong>[<em>i</em>] = <strong>c</strong><sub><em>i</em></sub>  ∀  <em>i</em> &lt; <em>n</em></span><br /> <br /><span class="math display">$$n = \left\lfloor\frac{c_{\mathrm{size}}}{J_{\mathrm{hashbytes}}}\right\rfloor$$</span><br /> The cache is calculated by performing <span class="math inline"><em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>r</em><em>o</em><em>u</em><em>n</em><em>d</em><em>s</em></sub></span> rounds of the RandMemoHash algorithm to the initial cache <span class="math inline"><strong>c</strong><strong>′</strong></span>: <br /><span class="math display"><strong>c</strong> = <em>E</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>r</em><em>o</em><em>u</em><em>n</em><em>d</em><em>s</em></sub>(<strong>c</strong><strong>′</strong>, <em>J</em><sub><em>c</em><em>a</em><em>c</em><em>h</em><em>e</em><em>r</em><em>o</em><em>u</em><em>n</em><em>d</em><em>s</em></sub>)</span><br /> <br /><span class="math display">$$E_{\mathrm{cacherounds}}(\mathbf{x}, y) = \begin{cases}
\mathbf{x} &amp; \text{if} \quad y = 0 \quad  \\
E_\text{\tiny RMH}(\mathbf{x}) &amp; \text{if} \quad y = 1 \quad  \\
E_{\mathrm{cacherounds}}(E_\text{\tiny RMH}(\mathbf{x}), y -1 ) &amp; \text{otherwise}
\end{cases}$$</span><br /> Where a single round modifies each subset of the cache as follows: <br /><span class="math display">$$E_\text{\tiny RMH}(\mathbf{x}) = \big( E_{\mathrm{rmh}}(\mathbf{x}, 0), E_{\mathrm{rmh}}(\mathbf{x}, 1), ... , E_{\mathrm{rmh}}(\mathbf{x}, n - 1) \big)\Hy@raisedlink{\hypertarget{E__cacherounds}{}}{}$$</span><br /> <br /><span class="math display">$$\begin{gathered}
  E_{\mathrm{rmh}}(\mathbf{x}, i) = \texttt{KEC512}(\mathbf{x'}[(i - 1 + n) \bmod n] \oplus \mathbf{x'}[\mathbf{x'}[i][0] \bmod n]) \\
  \text{with} \quad \mathbf{x'} = \mathbf{x} \quad \text{except} \quad \mathbf{x'}[j] = E_{\mathrm{rmh}}(\mathbf{x}, j) \quad \forall \quad j &lt; i\end{gathered}$$</span><br /></p>
<h3 id="dataset">Full dataset calculation</h3>
<p>Essentially, we combine data from <span class="math inline"><em>J</em><sub><em>p</em><em>a</em><em>r</em><em>e</em><em>n</em><em>t</em><em>s</em></sub></span> pseudorandomly selected cache nodes, and hash that to compute the dataset. The entire dataset is then generated by a number of items, each <span class="math inline"><em>J</em><sub><em>h</em><em>a</em><em>s</em><em>h</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> bytes in size: <br /><span class="math display">$$\mathbf{d}[i] = E_{\mathrm{datasetitem}}(\mathbf{c}, i) \quad \forall \quad i &lt; \left\lfloor\frac{d_{\mathrm{size}}}{J_{\mathrm{hashbytes}}}\right\rfloor$$</span><br /> In order to calculate the single item we use an algorithm inspired by the FNV hash (<span class="citation" data-cites="FowlerNollVo1991FNVHash"></span>) in some cases as a non-associative substitute for XOR. <br /><span class="math display">$$E_\text{\tiny FNV}(\mathbf{x}, \mathbf{y}) = (\mathbf{x} \cdot (\mathrm{0x01000193} \oplus \mathbf{y})) \bmod 2^{32}$$</span><br /> The single item of the dataset can now be calculated as: <br /><span class="math display"><em>E</em><sub><em>d</em><em>a</em><em>t</em><em>a</em><em>s</em><em>e</em><em>t</em><em>i</em><em>t</em><em>e</em><em>m</em></sub>(<strong>c</strong>, <em>i</em>) = <em>E</em><sub><em>p</em><em>a</em><em>r</em><em>e</em><em>n</em><em>t</em><em>s</em></sub>(<strong>c</strong>, <em>i</em>,  − 1, ⌀)</span><br /> <br /><span class="math display">$$E_{\mathrm{parents}}(\mathbf{c}, i, p, \mathbf{m}) = \begin{cases}
E_{\mathrm{parents}}(\mathbf{c}, i, p +1, E_{\mathrm{mix}}(\mathbf{m}, \mathbf{c}, i, p + 1)) &amp; \text{if} \quad p &lt; J_{\mathrm{parents}} -2 \\
E_{\mathrm{mix}}(\mathbf{m}, \mathbf{c}, i, p + 1) &amp; \text{otherwise}
\end{cases}$$</span><br /> <br /><span class="math display">$$E_{\mathrm{mix}}(\mathbf{m}, \mathbf{c}, i, p) = \begin{cases}
\texttt{KEC512}(\mathbf{c}[i \bmod c_\mathrm{{size}}] \oplus i) &amp; \text{if} \quad p = 0 \\
E_\text{\tiny FNV}\big(\mathbf{m}, \mathbf{c}[E_\text{\tiny FNV}(i \oplus p, \mathbf{m}[p \bmod \lfloor J_{\mathrm{hashbytes}} / J_{\mathrm{wordbytes}} \rfloor]) \bmod c_{\mathrm{size}}] \big) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<h2 id="proof-of-work-function">Proof-of-work function</h2>
<p>Essentially, we maintain a “mix” <span class="math inline"><em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> bytes wide, and repeatedly sequentially fetch <span class="math inline"><em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> bytes from the full dataset and use the <span class="math inline">$E_\text{\tiny FNV}$</span> function to combine it with the mix. <span class="math inline"><em>J</em><sub><em>m</em><em>i</em><em>x</em><em>b</em><em>y</em><em>t</em><em>e</em><em>s</em></sub></span> bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.</p>
<p>If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of <code>KEC</code> at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.</p>
<p>The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the concatenation of the compressed mix with the seed hash as the second item: <br /><span class="math display">$$\mathtt{PoW}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}, H_{\mathrm{n}}, \mathbf{d}) = \lbrace \mathbf{m}_{\mathrm{c}}(\mathtt{KEC}(\mathtt{RLP}(L_{\mathrm{H}}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}))), H_{\mathrm{n}}, \mathbf{d}), \texttt{KEC}(\mathbf{s}_{\mathrm{h}}(\mathtt{KEC}(\mathtt{RLP}(L_{\mathrm{H}}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}))), H_{\mathrm{n}}) + \mathbf{m}_{\mathrm{c}}(\mathtt{KEC}(\mathtt{RLP}(L_{\mathrm{H}}(H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}))), H_{\mathrm{n}}, \mathbf{d})) \rbrace$$</span><br /> With <span class="math inline">$H_{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {n};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}$</span> being the hash of the header without the nonce. The compressed mix <span class="math inline"><strong>m</strong><sub><em>c</em></sub></span> is obtained as follows: <br /><span class="math display">$$\mathbf{m}_{\mathrm{c}}(\mathbf{h}, \mathbf{n}, \mathbf{d}) = E_{\mathrm{compress}}(E_{\mathrm{accesses}}(\mathbf{d}, \sum_{i = 0}^{n_{\mathrm{mix}}} \mathbf{s}_{\mathrm{h}}(\mathbf{h}, \mathbf{n}), \mathbf{s}_{\mathrm{h}}(\mathbf{h}, \mathbf{n}), -1), -4)$$</span><br /></p>
<p>The seed hash being: <br /><span class="math display"><strong>s</strong><sub><em>h</em></sub>(<strong>h</strong>, <strong>n</strong>) = <code>KEC512</code>(<strong>h</strong> + <em>E</em><sub><em>r</em><em>e</em><em>v</em><em>e</em><em>r</em><em>t</em></sub>(<strong>n</strong>))</span><br /> <span class="math inline"><em>E</em><sub><em>r</em><em>e</em><em>v</em><em>e</em><em>r</em><em>t</em></sub>(<strong>n</strong>)</span> returns the reverted bytes sequence of the nonce <span class="math inline"><strong>n</strong></span>: <br /><span class="math display"><em>E</em><sub><em>r</em><em>e</em><em>v</em><em>e</em><em>r</em><em>t</em></sub>(<strong>n</strong>)[<em>i</em>] = <strong>n</strong>[∥<strong>n</strong>∥ − <em>i</em>]</span><br /> We note that the “<span class="math inline">+</span>”-operator between two byte sequences results in the concatenation of both sequences.</p>
<p>The dataset <span class="math inline"><strong>d</strong></span> is obtained as described in section <a href="#dataset" data-reference-type="ref" data-reference="dataset">26.3.3</a>.</p>
<p>The number of replicated sequences in the mix is: <br /><span class="math display">$$n_{\mathrm{mix}} =  \left\lfloor\frac{J_{\mathrm{mixbytes}}}{J_{\mathrm{hashbytes}}}\right\rfloor$$</span><br /> In order to add random dataset nodes to the mix, the <span class="math inline"><em>E</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em><em>e</em><em>s</em></sub></span> function is used: <br /><span class="math display">$$E_{\mathrm{accesses}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = \begin{cases}
E_{\mathrm{mixdataset}}(\mathbf{d}, \mathbf{m},  \mathbf{s}, i) &amp; \text{if} \quad i = J_{\mathrm{accesses}} -2 \\
E_{\mathrm{accesses}}(E_{\mathrm{mixdataset}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i), \mathbf{s}, i + 1) &amp; \text{otherwise}
\end{cases}$$</span><br /> <br /><span class="math display">$$E_{\mathrm{mixdataset}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = E_\text{\tiny FNV}(\mathbf{m}, E_{\mathrm{newdata}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i))$$</span><br /> <span class="math inline"><em>E</em><sub><em>n</em><em>e</em><em>w</em><em>d</em><em>a</em><em>t</em><em>a</em></sub></span> returns an array with <span class="math inline"><em>n</em><sub><em>m</em><em>i</em><em>x</em></sub></span> elements: <br /><span class="math display">$$E_{\mathrm{newdata}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)[j] = \mathbf{d}[E_\text{\tiny FNV}(i \oplus \mathbf{s}[0], \mathbf{m}[i \bmod \left\lfloor\frac{J_{\mathrm{mixbytes}}}{J_{\mathrm{wordbytes}}}\right\rfloor]) \bmod \left\lfloor\frac{d_{\mathrm{size}} / J_{\mathrm{hashbytes}}}{n_{\mathrm{mix}}}\right\rfloor \cdot n_{\mathrm{mix}} + j] \quad \forall \quad j &lt; n_{\mathrm{mix}}$$</span><br /> The mix is compressed as follows: <br /><span class="math display">$$E_{\mathrm{compress}}(\mathbf{m}, i) = \begin{cases}
\mathbf{m} &amp; \text{if} \quad i \geqslant \lVert \mathbf{m} \rVert - 8 \\
E_{\mathrm{compress}}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(\mathbf{m}[i + 4], \mathbf{m}[i + 5]), \mathbf{m}[i + 6]), \mathbf{m}[i + 7]), i + 8) &amp; \text{otherwise}
\end{cases}$$</span><br /></p>
<h1 id="anomalies-on-the-main-network">Anomalies on the Main Network</h1>
<h2 id="deletion-of-an-account-despite-out-of-gas">Deletion of an Account Despite Out-of-gas</h2>
<p>At block 2675119, in the transaction , an account at address 0x03 was called and an out-of-gas occurred during the call. Against the equation (<a href="#eq:pre" data-reference-type="ref" data-reference="eq:pre">[eq:pre]</a>), this added 0x03 in the set of touched addresses, and this transaction turned <span class="math inline"><strong>σ</strong>[0<em>x</em>03]</span> into <span class="math inline">⌀</span>.</p>
<h1 id="app:symbols">List of mathematical symbols</h1>
<p><span>c c X[j]</span> Symbol &amp; Latex Command &amp; Description<br />
<span class="math inline">⋁</span> &amp; <code>\bigvee</code> &amp; This is the least upper bound, supremum, or join of all elements operated on. Thus it is the greatest element of such elements (<span class="citation" data-cites="Davey2002_zbMATH01748069"></span>).<br />
</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Notably, such ‘tools’ could ultimately become so causally removed from their human-based initiation—or humans may become so causally-neutral—that there could be a point at which they rightly be considered autonomous agents. e.g. contracts may offer bounties to humans for being sent transactions to initiate their execution.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><em>ommer</em> is a gender-neutral term to mean “sibling of parent”; see <a href="https://nonbinary.miraheze.org/wiki/Gender_neutral_language_in_English#Aunt/Uncle">https://nonbinary.miraheze.org/wiki/Gender_neutral_language_in_English#Aunt/Uncle</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>2048 <span class="math inline"> = 2<sup>11</sup></span>(11 bits), and the low-order 11 bits is the modulo 2048 of the operand, which is in this case is "each of the first three pairs of bytes in a Keccak-256 hash of the byte sequence."<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>which can differ from the sender in the case of a message call or contract creation not directly triggered by a transaction but coming from the execution of EVM-code<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>During initialization code execution, <code>EXTCODESIZE</code> on the address should return zero, which is the length of the code of the account while <code>CODESIZE</code> should return the length of the initialization code (as defined in <a href="#subsec:instruction-set" data-reference-type="ref" data-reference="subsec:instruction-set">24.2</a>).<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
